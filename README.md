# LearnGolang
# Golang learnign

# **Срезы (слайсы, slices)**

## **Понятие среза**

Срез — это последовательность элементов одного типа переменной длины.

Массивы и срезы тесно связаны. Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива. Длину массива изменять нельзя, а вот новые элементы в срез добавлять можно, так что в некоторых языках срезами называются динамические массивы.

Срез состоит из трех компонентов: указателя, длины и емкости:

- указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
- длина (length) — это количество элементов среза;
- емкость (capacity) - количество элементов между началом среза и концом базового массива.

Длина и емкость среза могут быть определены при помощи встроенных функций len() и cap() соответственно.

## **Создание среза**

### **Создание пустого среза**

Пустой срез может быть создан аналогично созданию массива за тем исключением, что нам нет необходимости указывать длину среза, поскольку она изменяема. При создании пустого среза мы также можем инициализировать его, явно указав элементы среза. Давайте рассмотрим, чем различается создание массива и среза:

```go
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}

fmt.Println(a) // []
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12]
```

Варианты b и c идентичны тем, что мы уже видели при создании массива (вы можете вернуться к ранее приведенным примерам и удостовериться в этом).

В том случае, если мы просто объявляем пустой срез, он не содержит элементов (его длина равна 0, в чем мы можем удостовериться, воспользовавшись функцией len) - в аналогичном случае длина массива явно задается при его объявлении.

Вариант d позволяет нам создать срез и явно указать значения элементов по его индексу, Go инициализирует нужное для выполнения этой задачи число элементов нулевым значением: в примере элемент с индексом 0 равен 0, хотя мы не объявляли его явно.

На этом способы создания среза в Go не заканчиваются. Для гибкого способа создания пустых срезов в Go существует встроенная функция make следующего вида:

```go
make([]T, length, capacity)
```

Чтобы разобраться с этой функцией нам нужно посмотреть, что происходит при создании пустого среза: Go создает массив какой-то длины. О понятии среза мы говорили выше: указатель среза будет указывать на первый элемент созданного массива, длина среза составит 0 (если мы явно не указали элементы среза), емкость необходимого массива будет определена Go самостоятельно.

Для чего нам может потребоваться явно указать длину и емкость среза:

- для того, чтобы инициализировать нулевыми значениями элементы массива (длина среза);
- для того, чтобы выделить нужное количество памяти для хранения массива, лежащего в основе нашего среза.

```go
a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0]
fmt.Println(a)
```

Функция make широко применяется на практике, в дальнейшем вы не раз будете использовать ее.

Теперь самое время вернуться к вопросу о длине и емкости среза, чтобы в контексте работы функции append рассмотреть внутренне устройство срезов. Что произойдет, если добавить в срез длины N и такой же емкости элементов больше N? Посмотрим на примере:

```go
baseArray := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
fmt.Printf("Базовый массив: %v\n", baseArray)

baseSlice := baseArray[5:8]
fmt.Printf(
    "Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
    len(baseSlice),
    cap(baseSlice),
    baseSlice,
)

// Output:
// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
// Срез, основанный на базовом массиве длиной 3 и емкостью 5: [5 6 7]
```

И так, мы создали массив из 10 элементов типа int, а затем создали срез на его элементы 5-7 (значения элементов в примере соответствуют их индексам). Таким образом длина среза составляет 3, а емкость 5 (если вы не понимаете, почему получилось именно так, посмотрите еще раз [в шестом шаге этого урока](https://stepik.org/lesson/228265/step/6?unit=200798), из каких компонентов состоит срез).

Теперь проведем небольшую подготовительную работу. Мы знаем, что один из компонентов среза: указатель на элемент массива, который является первым элементом среза. Сохраним этот указатель в переменной pointer в виде строки (мы не будем его печатать, т.к. во время каждого исполнения программы он будет разным, но мы сможем использовать сохраненное значение для сравнения):

```go
pointer := fmt.Sprintf("%p", baseSlice)
```

*Напоминание: Конструкция %p говорит, что в качестве результата должен быть возвращен адрес элемента массива, на который ссылается baseSlice.*

Теперь добавим новый элемент в наш срез и посмотрим, как это повлияет на наш базовый массив:

```go
baseSlice = append(baseSlice, 10)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 4 и емкостью 5: [5 6 7 10]
// true
```

Мы видим, что изменился не только наш срез, но и базовый массив, на который ссылается срез. Длина среза изменилась автоматически. А теперь повторим предыдущую операцию, но добавим столько элементов, чтобы емкости среза не хватило:

```go
baseSlice = append(baseSlice, 11, 12, 13)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
// false
```

Мы видим, что базовый массив не изменился, а наш срез теперь ссылается на другой массив и имеет емкость больше длины. Почему так произошло? При добавлении элементов в срез Go проверяет, достаточно ли емкости среза для добавления новых элементов в срез (т.е. есть ли еще место в массиве, на котором основан срез). Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а также добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go: создав один раз срез на основе массива достаточной нам длины, мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.

### Использование append для удаления элемента из среза

В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:

```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

*В этом примере встречается символ ... после указания на передачу среза в качестве аргумента. Этот вопрос также будет повторно рассмотрен в разделе 2.1. Функции. В настоящий момент можете запомнить, что такое использование многоточия означает раскрытие среза (его элементы передаются функции append как отдельные аргументы).*

### **Функция copy - копирование элементов среза**

Сразу рассмотрим описание функции:

```go
func copy(dst, src []Type) int
// про функции мы поговорим в 2 модуле, ничего страшного если вам не очень понятно ;)
```

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

Почему мы явно указали длину создаваемого среза b? Потому что иначе функции было бы некуда копировать. Имей срез b длину 1, был бы скопирован 1 элемент из среза a.

# Условные конструкции

### **Условная конструкция if**

Конструкция `if` принимает условие - выражение, которое возвращает значение типа `bool`. Если это условие истинно, то выполняется последующий блок инструкций:

```go
package main

import "fmt"

func main() {
   a := 6
   b := 7
   if a < b {
      fmt.Println("a меньше, чем b")
  }
}
```

### **If с краткой инструкцией**

Так же как и for (про него в следующем уроке), оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца if. Пример:

```go
if v := math.Pow(x, n); v < lim {
   // ...
}
```

### **Условные конструкции else if и else**

Если нам нужно проверить несколько условий, мы можем использовать оператор `else if`:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}
```

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор `else`:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

### **Switch**

Предположим, мы захотели написать программу, которая печатала бы английские названия для чисел. С использованием того, что мы знали до текущего момента, это могло бы выглядеть примерно так:

```go
if i == 0 {
    fmt.Println("Zero")
} else if i == 1 {
    fmt.Println("One")
} else if i == 2 {
    fmt.Println("Two")
} else if i == 3 {
    fmt.Println("Three")
} else if i == 4 {
    fmt.Println("Four")
} else if i == 5 {
    fmt.Println("Five")
}
```

Но эта запись слишком громоздка. Go содержит в себе другой оператор, позволяющий делать такие вещи проще: оператор `switch` (переключатель). С ним программа может выглядеть так:

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Переключатель начинается с ключевого слова `switch`, за которым следует выражение (в нашем случае `i`) и серия возможных значений (`case`). Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова `case`. Если они оказываются равны, то выполняется действие, описанное после `:`.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением. Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает `else` в операторе `if`).

В **switch** можно использовать любой тип данных.

### **Стоит дополнить, что:**

1. В Go код после **case** выполняется до следующего case, и нет нужды каждый case-блок заканчивать ключевым словом **break** (данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в switch-блоках). Если в текущем `case` написать `fallthrough`, то тело следующего `case` выполнится вне зависимости от того истинно ли его (следующего `case`) условие:

```go
v := 42
switch v {
case 100:
	fmt.Println(100)
	fallthrough
case 42:
	fmt.Println(42)
	fallthrough
case 1:
	fmt.Println(1)
	fallthrough
default:
	fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```

2. Существует специальная форма **switch**, допускающая использование произвольных условий в каждом case-блоке:

```go
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
	fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
	fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
	fmt.Println("от 1000 до 6000")
}
```

То есть, сразу после switch "переключатель" не нужен, а после каждого case идет выражение с произвольным условием.

### **Циклы в Go**

Единственной конструкцией для циклов в Go является оператор `for`.

Его базовая форма выглядит следующим образом:

```less
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

Пример использования:

```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 1; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

Объявление цикла `for` разбивается на три части. Вначале идет инициализация счетчика: `i := 1`. Фактически она представляет объявление переменной, которая будет использоваться внутри цикла. В данном случае это счетчик i, начальное значение которого равно 1.

Вторая часть представляет условие: `i < 10`. Пока это условие истинно, то есть возвращает true, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.

Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:

```go
var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}
```

Можно убрать изменение счетчика в само тело цикла и оставить только условие:

```go
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

Если цикл использует только условие, то его можно сократить следующим образом:

```go
var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}
```

При этом в последнем случае мы получим по сути аналог цикла `while` в других языках программирования.

Так же можно реализовать бесконечный цикл:

```go
for {

}
```

**Кстати**, иногда удобно пользоваться такой конструкцией ввода данных:

(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)

```go
var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}
```

## **Форматированный вывод**

Ряд возможностей для вывода и не только предоставляет пакет [fmt](https://golang.org/pkg/fmt). До этого мы использовали только `Print` и `Println`, а что если нам понадобится вывести, допустим у числа **float64** только 2 знака после запятой. Подобные операции удобно делать через функцию `Printf`. Давайте рассмотрим основные возможности.

`fmt.Printf()` на вход принимает сначала строку форматирования, а только потом переменные для вывода. Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента %.  В качестве примера возьмем глагол - спецификатор `%q` , с помощью него можно вывести символ в кавычках:

```go
var a rune = 'Ы'
fmt.Printf("%q", a)
// вывод: 'Ы'

```

Каждый спецификатор представляет определенный тип данных:

- `%t`: для вывода значений типа boolean (true или false)
- `%b`: для вывода целых чисел в двоичной системе
- `%c`: для вывода символов, представленных числовым кодом
- `%d`: для вывода целых чисел в десятичной системе
- `%o`: для вывода целых чисел в восьмеричной системе
- `%q`: для вывода символов в одинарных кавычках
- `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
- `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
- `%U`: для вывода символов в формате кодов Unicode, например, U+1234
- `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
- `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
- `%f`: для вывода чисел с плавающей точкой, например, 123.456
- `%F`: то же самое, что и %f
- `%g`  %e для огромных экспонент, %f в противном случае
- `%G` %E для огромных экспонент, %F в противном случае
- `%s`: для вывода строки
- `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
- `%T` для вывода типа переменной

Также можно применять универсальный спецификатор `%v`, который для типа boolean аналогичен `%t`, для целочисленных типов - `%d`, для чисел с плавающей точкой - `%g`, для строк - `%s`.

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, `%9f` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

- `%f`: точность и ширина значения по умолчанию
- `%9f`: ширина - 9 символов и точность по умолчанию
    
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
    
- `%.2f`: ширина по умолчанию и точность - 2 символа
- `%9.2f`: ширина - 9 и точность - 2
- `%9.f`: ширина - 9 и точность - 0

Также из флагов следует отметить дефис -, который дополняет значение пробелами не слева, как по умолчанию, а справа.

Примеры:

```go
var a float64 = 100.123456
fmt.Printf("это число %f типа %T", a, a)
// вывод: это число 100.123456 типа float64

var a1 byte = 's'
var a2 int = 1234
fmt.Printf("%q %b", a1, a2)
// вывод: 's' 10011010010

// использование \n позволяет сделать перенос строки
var a1 string = "123"
var a2 string = "1234"
fmt.Printf("%q \n%s", a1, a2)
// вывод:
// "123"
// 1234
```

## **Sprintf**

Также есть функция Sprintf() которая работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:

```go
package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a)
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}
```

Мы рассмотрели только основные возможности пакета fmt которые вам будут нужны для решения последующих задач и примеров в курсе, более подробно пакет можно изучить в официальной [документации](https://golang.org/pkg/fmt/).

## **Литералы строк**

Вначале определим разницу между *литералами строк* и *значениями строк*. Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки. Значение строки — это то, что мы видим в окне терминала когда вызываем функцию `fmt.Println` после запуска программы Go.

В простой программе Hello, World! литерал строки будет выглядеть как `"Hello, World!"`, а значением строки будет `Hello, World!` без кавычек.

Однако для некоторых значений строк могут требоваться кавычки, в частности в случае с цитатами. Поскольку литералы строк и значения строк не эквивалентны, часто требуется добавлять в литералы строк дополнительное форматирование, чтобы значения строк отображались ожидаемым образом.

## **Кавычки и обратный апостроф**

В Go можно использовать обратный апостроф (```) или двойные кавычки (`"`), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами:

```
`Sammy says, "Hello!"`
```

Также вы можете использовать обратные апострофы и заключить строку в двойные кавычки:

```
"Sammy likes the `fmt` package for formatting strings.."
```

Кроме того, комбинирование обратных апострофов и двойных кавычек позволяет контролировать отображение символов кавычек и одинарных кавычек в строках.

Важно помнить, что при использовании обратных апострофов в Go создается чистый литерал строки, а при использовании двойных кавычек — интерпретированный литерал строки. Чтобы узнать больше о разнице между ними, ознакомьтесь с руководством [Введение в работу со строками в Go](https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go).

## **Управляющие символы**

Также для форматирования строк используются *управляющие символы*. Управляющие символы интерпретируются кодом как имеющие особое значение. Управляющие символы начинаются с обратной косой черты (`\`), за которой идет другой символ строки, в результате чего строка имеет определенный формат.

Далее приведен перечень нескольких распространенных управляющих символов, а также примеры экранирования:

[Untitled Database](https://www.notion.so/7977ea9c50944548a4a40e3e06d1d650?pvs=21)

Так же есть \a - особый управляющий символ, необходимый для создания звука (alert).

Символ обратного слеша `\` кроме использования в управляющих символах, также используется для экранирования символов. Например, в ситуации, когда нам нужно поместить в строку двойные кавычки, мы не можем вставить их напрямую, но можем вставить используя экранирование (в этом случае символ идущий после обратного слеша будет выведен в строке как есть):

```less
fmt.Println("Sammy says, \"Hello!\"")
```

`Output`

`Sammy says, "Hello!"`

С помощью экранирования мы можем использовать двойные кавычки, чтобы заключить строку с текстом в двойные кавычки.

Управляющий символ `\n` можно использовать для перевода строки без нажатия клавиши Enter (Return):

```
fmt.Println("This string\nspans multiple\nlines.")
```

`Output`

```
This string
spans multiple
lines.
```

Управляющие символы при желании можно комбинировать. Например, мы можем вывести список позиций, напечатав строку из нескольких рядов и добавив разделители в виде табуляции:

```
fmt.Println("1.\tShark\n2.\tShrimp\n10.\tSquid")
```

`Output`

```markdown
1.	Shark
2.	Shrimp
10.	Squid
```

Горизонтальные отступы, создаваемые за счет управляющего символа `\t`, обеспечивают выравнивание со вторым столбцом в предыдущем примере, что делает выводимый текст удобным для чтения.

Управляющие символы и экранирование используются для добавления в строки дополнительного форматирования, которого иным образом достичь сложно или невозможно. Без управляющих символов и экранирования вы не сможете построить строку `Сэмми говорит: "Мне нравится использовать пакет `fmt`"`.

## **Многострочная печать**

Многострочная печать строк делает текст более удобным для чтения. Размещение строк в нескольких рядах делает текст более понятным и упорядоченным, позволяет форматировать его как письмо или сохранить разрывы строк в стихотворении или тексте песни.

Для создания строк, отображаемых на нескольких рядах, их нужно заключить в обратные апострофы. Помните, что хотя при этом сохраняются символы возврата строки, создаваться будут `чистые` литералы строки.

```go
`
This string is on
multiple lines
within three single
quotes on either side.
`
```

Если вы распечатаете этот текст, вы увидите, что символ возврата имеется в начале и в конце строки:

`Output`

```
This string is on
multiple lines
within three single
quotes on either side.
```

Во избежание этого следует поместить первый ряд сразу же за обратным апострофом и закончить последний ряд обратным апострофом.

```go
`This string is on
multiple lines
within three single
quotes on either side.`
```

Если вам нужно создать интерпретированный литерал строки, вы можете использовать двойные кавычки и оператор `+`, но при этом вам нужно будет самостоятельно вставлять символы разрыва строки между рядами.

```
"This string is on\n" +
"multiple lines\n" +
"within three single\n" +
"quotes on either side."
```

Хотя с обратными апострофами намного проще распечатывать и читать длинный текст, если вам требуется интерпретированный литерал строки, вам нужно использовать двойные кавычки.

## **Чистые литералы строк**

Что, если нам не нужно особое форматирование строк? Например, нам может понадобиться сравнить или оценить несколько строк программного кода, где целенаправленно используется символ обратного слеша, так что мы не хотим, чтобы Go использовал этот символ как управляющий или как элемент экранирования.

**Чистый** литерал строки указывает Go игнорировать все форматирование строки, включая управляющие символы.

Мы можем создать чистую строку, заключив строку в обратные апострофы:

```livescript
fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)
```

`Output`

`Sammy says,\"The balloon\'s color is red.\"`

Построение чистой строки с помощью обратных апострофов вокруг нее позволяет сохранить в тексте символы обратного слеша и другие символы, которые используются в качестве управляющих символов.

# **Числа**

В Go есть несколько различных типов для представления чисел. Вообще, мы разделим числа на два различных класса: целые числа и числа с плавающей точкой.

### **Целые числа**

Целые числа, точно так же, как их математические коллеги, — это числа без дробной части. В отличие от десятичного представления чисел, которое используем мы, компьютеры используют двоичное представление.

Наша система строится на 10 различных цифрах. Когда мы исчерпываем доступные нам цифры, мы представляем большое число, используя новую цифру 2 (а затем 3, 4, 5, …) числа следуют одно за другим. Например, число, следующее за 9, это 10, число, следующее за 99, это 100 и так далее. Компьютеры делают то же самое, но они имеют только 2 цифры вместо 10. Поэтому, подсчет выглядит так: 0, 1, 10, 11, 100, 101, 110, 111 и так далее. Другое отличие между той системой счисления, что используем мы, и той, что использует компьютер - все типы чисел имеют строго определенный размер. У них есть ограниченное количество цифр. Поэтому четырехразрядное число может выглядеть так: 0000, 0001, 0010, 0011, 0100. В конце концов мы можем выйти за лимит, и большинство компьютеров просто вернутся к самому началу (что может стать причиной очень странного поведения программы).

В Go существуют следующие типы целых чисел: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32` и `int64`. 8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип. `uint` означает «unsigned integer» (беззнаковое целое), в то время как `int` означает «signed integer» (знаковое целое). Беззнаковое целое может принимать только положительные значения (или ноль).

| uint8 | Беззнаковые 8-битные целые числа | от 0 до 255 |
| --- | --- | --- |
| uint16 | Беззнаковые 16-битные целые числа | от 0 до 65535 |
| uint32 | Беззнаковые 32-битные целые числа | от 0 до 4294967295 |
| uint64 | Беззнаковые 64-битные целые числа | от 0 до 18446744073709551615 |
| int8 | Знаковые 8-битные целые числа | от -128 до 127 |
| int16 | Знаковые 16-битные целые числа | от -32768 до 32767 |
| int32 | Знаковые 32-битные целые числа | от -2147483648 до 2147483647 |
| int64 | Знаковые 64-битные целые числа | от -9223372036854775808 до 9223372036854775807 |

В дополнение к этому существуют два типа-псевдонима: `byte` (то же самое, что `uint8`) и `rune` (то же самое, что `int32`). Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип `byte` в Go часто используется для определения других типов.

Также существует 3 машинно-зависимых целочисленных типа: `uint`, `int` и `uintptr`. Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:

- `int`: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.
- `uint`: представляет целое число только без знака, которое, аналогично типу int, в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

В общем, если вы работаете с целыми числами — просто используйте тип `int`.

# ***Функции***

Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:

```go
func имя_функции (список_параметров) (типы_возвращаемых_значений) {
    выполняемые_операторы
}
```

Пример функции:

```go
func main() {
   hello()
}

func hello() {
    fmt.Println("Hello World")
}

```

**Важно!** Открывающая фигурная скобка должна располагаться на той же строке, что и объявление функции, иначе вы получите ошибку. Это сделано для единого стиля кода.

**Напоминаем,** краткое объявление переменных (a := 5) работает только внутри функций.

### **Параметры функции**

Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции. Для каждого параметра указывается имя и тип (как для переменной). Друг от друга параметры разделяются запятыми. При вызове функции необходимо передать значения для всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:

```go
package main
import "fmt"

func main() {
    add(4, 5)   // x + y = 9
    add(20, 6)  // x + y = 26
}

func add(x int, y int){
    var z = x + y
    fmt.Println("x + y = ", z)
}
```

Функция add имеет два параметра: x и y. Оба параметра представляют тип int, то есть целые числа. В самой функции определяется переменная, которая хранит сумму этих чисел. И затем сумма чисел выводится на консоль.

В функции main вызывается функция add. Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента. Причем эти значения должны соответствовать параметрам по типу. То есть если параметр представляет тип int, то ему необходимо передать число.

Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - второй параметр и так далее. В итоге мы получим следующий консольный вывод:

```go
x + y = 9
x + y = 26
```

Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:

```go
package main
import "fmt"

func main() {
    add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)
}
```

В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что если аргументы в функцию передаются по значению то они копируются:

```go
package main
import "fmt"

func main() {
    var a = 8
    fmt.Println("a before: ", a)
    increment(a)
    fmt.Println("a after: ", a)
}
func increment(x int){

    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}
```

Вывод:

```go
a before: 8
x before: 8
x after: 28
a after: 8
```

В данном случае в качестве аргумента в функцию increment передается значение переменной a. Параметр x получает это значение, и оно увеличивается на 20. Однако несмотря на то, что значение параметра x увеличилось, значение переменной a никак не изменилось. Потому что при вызове функции передается копия значения переменной.

### **Возвращение результата из функции**

Функции могут возвращать результат. Для этого нужно после списка параметров функции указать тип возвращаемого результата. А в теле функции использовать оператор `return`, после которого указывается возвращаемое значение:

```go
func имя_функции (список_параметров) тип_возвращаемого_значения {
    выполняемые_операторы
    return возвращаемое_значение
}
```

Например, мы хотим возвратить из функции сумму двух чисел:

```go
package main
import "fmt"

func main() {
    var a = add(4, 5)   // 9
    var b = add(20, 6)  // 26
    fmt.Println(a)
    fmt.Println(b)
}

func add(x, y int) int {
    return x + y
}
```

Функция `add` возвращает значение типа `int`, поэтому данный тип указан после списка параметров. В самой функции после оператора `return` указывается возвращаемое значение. При этом данное значение может быть значением переменной, литералом, либо же, как в данном случае, результатом операции или вызова функции. То есть выражение `x + y` определяет возвращаемое значение.

Поскольку функция возвращает значение, то при вызове функции мы можем получить это значение и передать его переменной:

```go
var a = add(4, 5)   // 9
var b = add(20, 6)  // 26
```

### **Возвращение нескольких значений**

В Go функция может возвращать сразу несколько значений. В этом случае после списка параметров указывается в скобках список типов возвращаемых значений. А после оператора return располагаются через запятую все возвращаемые значения:

```go
package main
import "fmt"

func main() {
    var age, name = add(4, 5, "Tom", "Simpson")
    fmt.Println(age)    // 9
    fmt.Println(name)   // Tom Simpson
}

func add(x, y int, firstName, lastName string) (int , string) {
    var z int = x + y
    var fullName = firstName + " " + lastName
    return z, fullName
}
```

Функция add принимает четыре параметра: два числа и две строки. Возвращает число (значение типа int) и строку. Возвращаемые значения указаны после оператора return.

Поскольку функция теперь возвращает два значения, то при вызове этой функции мы можем присвоить ее результат двум переменным:

```go
var age, name = add(4, 5, "Tom", "Simpson")
```

Первое возвращаемое значение передается первой переменной age, а второе значение передается второй переменной name.

Альтернативный способ передачи переменным результатов функции:

```go
age, name := add(4, 5, "Tom", "Simpson")
```

### **Игнорирование возвращаемых значений**

Go позволяет проигнорировать все или определенные возвращаемые функцией значения, если мы не будем использовать их в дальнейшем. Для этого нам необходимо не присваивать им имена вообще либо заменить имя символом _. Рассмотрим это на примере:

```go
func fn() (int, error) {
	// Какая-то полезная работа
	// ...
	return 0, nil
}
func ExampleIgnor() {
	fn()

	i, _ := fn()
	fmt.Println(i)

	_, err := fn()
	if err == nil {
		fmt.Println("Ошибок нет")
	}

	// Output:
	// 0
	// Ошибок нет
}

```

Здесь мы создали функцию-заглушку, возвращающую 2 значения: число и ошибка.

В первом примере мы проигнорировали оба возвращаемых значения, выполнив полезную работу функции (так мы часто делаем, когда используем функцию fmt.Print - игнорируя возвращаемые ею значения).

Во втором примере мы проигнорировали сообщение об ошибке (не делайте так), а в третьем - только проверили, возвратила ли функция ошибку, проигнорировав возвращаемое число.

### **Функции с переменным количеством параметров (аргументов)**

В завершении данной темы необходимо рассмотреть возможность передачи в функцию переменного количества аргументов. Для примера рассмотрим как выглядит функция Print из пакета fmt стандартной библиотеки:

```go
func Print(a ...interface{}) (n int, err error) // interface мы рассмотрим в 3 модуле, это лишь для примера
```

Мы видим, что функция принимает аргумент a типа interface{}, но перед указанием типа имеется знак многоточия (…). Символ многоточия перед указанием типа указывает, что в функцию можно передать произвольное количество параметров указанного типа. Посмотрим, как это выглядит на практике:

```go
func ExamplePrint() {
	fmt.Print(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```

Функция получила 5 аргументов произвольного типа (в примере это числа) и напечатала их все. Разберемся, как работает данная функция.

Аргумент с именем a воспринимается функцией как срез элементов заданного типа interface{}, внутри функция работает с элементами этого среза соответствующим образом. Вот так эта функция могла бы выглядеть (под капотом реализация функции гораздо сложнее, но мы рассмотрим лишь необходимую нам часть функционала):

```go
func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Printf("%d ", elem)
	}
}

func ExampleMyPrint() {
	myPrint(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```

Для примера мы реализовали функцию-обертку над fmt.Printf, чтобы показать, как обрабатывается переменное число аргументов.

Необходимо запомнить, что если функция принимает определенные аргументы и еще произвольное число аргументов определенного типа, то при объявлении функции эти «переменные» аргументы указываются в самом конце. Для примера:

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
```

Эта функция принимает обязательный аргумент тип io.Writer и произвольное число аргументов типа interface{}.

*В рамках данного урока вы неоднократно сталкивались с таким типом как interface{}, данная тема будет подробно рассмотрена в 3 модуле данного курса, пока же вы можете запомнить что использование этого типа (пустого интерфейса) означает, что функция может получить аргумент любого типа: строку, число, структуру и т.д.*

### **Небольшое дополнение по использованию многоточия (...)**

Как мы выяснили, знак многоточия *слева* от указания на тип передаваемого значения свидетельствует о возможности передать в функцию неопределенное количество аргументов указанного типа, внутри функции переданные аргументы *будут обработаны как срез указанного в объявлении функции типа*.

Однако язык Go предусматривает обратный способ использования многоточия - разворачивание (раскрытие) среза путем указания *справа* от среза знака многоточия. Приведу 2 примера:

```go
func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}
```

В первом примере мы создали срез типа []interface, а затем напечатали его в виде среза и в виде отдельных значений, входящих в него.

Важный вопрос, почему мы использовали тип []interface вместо типа []int? Это связано с механикой приведения типов в Go, в силу которой []int не является []interface. Но т.к. интерфейсы будут рассмотрены только в следующем модуле, рассмотрим эту проблему в дальнейшем.

В следующем примере мы создаем 2 среза типа []int, а затем используем встроенную функцию append для того, чтобы в элементы первого среза добавить элементы второго среза. Сигнатура функции приведена в самом примере в виде комментария: первый аргумент - срез указанного типа, далее следует неопределенное число аргументов указанного типа.

Использовав разворачивание среза s2 мы передадим в функцию сразу все его элементы.

```go
func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	// append(slice []Type, elems ...Type) []Type

	// s1 = append(s1, s2) не сработает, т.к. второй и
	// последующие аргументы в нашем случае должны быть int

	s1 = append(s1, s2...)
	fmt.Println(s1)

	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}
```

# **Пакеты**

Весь код в языке Go организуется в пакеты. Пакеты представляют удобную организацию разделения кода на отдельные части или модули. Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многократно в различных программах.

Код пакета располагается в одном или нескольких файлах с расширением `go`. Для определения пакета применяется ключевое слово `package`. Например:

```go
package main

import "fmt"

func main() {

    fmt.Println("Hello Go")
}
```

В данном случае пакет называется `main`. Определение пакета должно идти в начале файла.

Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя `main`. Все остальные пакеты не являются исполняемыми. При этом пакет **main** должен содержать функцию `main`, которая является входной точкой в приложение.

### **Импорт пакетов**

Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора `import`. Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции `Println`, которая определена в пакете `fmt`. Соответственно чтобы использовать эту функцию, необходимо импортировать пакет `fmt`:

```go
import "fmt"
```

Нередко программы подключают сразу несколько внешних пакетов. В этом случае можно последовательно импортировать каждый пакет:

```go
package main

import "fmt"
import "math"

func main() {

    fmt.Println(math.Sqrt(16))  // 4
}
```

В данном случае подключается встроенный пакет `math`, который содержит функцию `Sqrt()`, возвращающую квадратный корень числа.

Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:

```go
package main

import (
    "fmt"
    "math"
)

func main() {

    fmt.Println(math.Sqrt(16))
}
```

Подобным образом мы можем импортировать как встроенные пакеты, так и свои собственные. Полный список встроенных пакетов в Go можно найти по адресу https://golang.org/pkg/.

Если вы знакомы с другими языками программирования, вам возможно знакомы конструкции типа таких:v

```cpp
using namespace std  // C++
```

```python
from math import *   # python
```

Они позволяют использовать функции из импортируемых пакетов без указания имени самого пакета. **Хотя это считается не самой лучшей практикой**, тем не менее в Go есть аналогичный способ импорта - импорт с точкой:

```go
package main

import . "fmt"

func main() {
    Println("Hello, Go!")
}
```

или же:

```go
package main

import (
    . "fmt"
)

func main() {
    Println("Hello, Go!")
}
```

Импорт с точкой добавляет все экспортируемые поля пакета в текущий скоуп (точнее говоря область видимости файла). И теперь вы можете работать с полями импортированного пакет так, как будто они у вас в пакете.

## **Импорт c синонимом**

Так же мы можем присвоить импорту "синоним" - то есть заменить fmt на другое слово при использовании этого пакета.

```go
package main

import custom "fmt"

func main() {
	custom.Println("Hello!")
}

```

Пакеты импортируют, задавая синонимы, в нескольких случаях:

- Имя импортируемого пакета неудобное/некрасивое/… и хочется использовать другое;
- Имя импортируемого пересекается с именем другого пакета;
- Хочется бесшовно подменить пакет — интерфейсы пакетов должны совпадат

В Go нет стандартного ООП как в C++/Java/C# и других языках. Поэтому и классов здесь нет, но есть пакеты. Большие программы принято разделять на пакеты, чтобы упростить её чтение.

Создадим в проекте два файла: один - main.go, другой - main2.go. Но оба файла лежат в одном пакете, потому что мы прописали package main. Поэтому мы без импорта можем вызывать функции из другого файла.

https://ucarecdn.com/f94c07c9-3bf2-4560-ad4c-e20d6d482af1/

Для запуска программы выше необходимо указать **все файлы пакета main** через пробел**:**

```go
go run main.go main2.go
```

# Указатели детка

Нет смысла рассказывать про указатели, если у читателя нет понимания о том, что такое "память компьютера". Это поправимо.

*Объяснение в прошлой версии урока вводило в заблуждение многих учеников. Мы решили, что использовать ролики из открытых источников - не стыдно.*

[Как работает память компьютера? [Ted Ed на русском]](https://youtu.be/CnsxNw2Unj8)

Теперь, когда мы имеем представление об ОЗУ, а переменные - названия ячеек памяти, надо разобраться с указателями.

Указатель - значение, которое указывает на адрес другой переменной. Рассмотрим это на примере:

```css
func main() {
        a := 200
        b := &a
        *b++
        fmt.Println(a)
}
```

В этом примере мы инициализируем переменную **а** и ссылающуюся на неё переменную **b**, мы не знаем, где она лежит, однако компилятор об этом позаботится. Оператор **&** (взятие адреса) говорит о том, что в переменную **b** записывается не значение переменной **a,** а её адрес в памяти. Переменная **b** здесь является указателем.

- **** является признаком указателя, то есть Вы работаете не с переменной **b**, а с переменной, на которую ссылается указатель

Иначе можно записать так:

```
a := 200
var b *int = &a
```

```
*int - значит переменная указывает на другую переменную типаint
```

Третья строчка - концентрация всей темы. В ней мы увеличиваем значение переменной **а**, т.к переменная **b** ссылается на адрес переменной **a**.

Подробнее про принципы работы памяти можно узнать здесь:

https://www.youtube.com/watch?v=0A1e8eceIsY

https://www.youtube.com/watch?v=XETZoRYdtkw

Другой способ получить указатель — использовать встроенную функцию `new`:

```go
func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}

```

Функция `new` принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

В некоторых языках программирования есть существенная разница между использованием `new` и `&`, и в них нужно удалять всё, что было создано с помощью `new`. Go не такой - Go хороший. Go — язык с автоматической сборкой мусора. Это означает, что область памяти очищается автоматически, когда на неё не остаётся ссылок.

Указатели редко используются в Go для встроенных типов, но они будут часто фигурировать в следующей главе (они чрезвычайно полезны при работе со структурами).

Так же рекомендуем дополнительно прочитать интересную статью по теме https://habr.com/en/post/339192/

# **Структуры**

С помощью структур эту программу можно сделать гораздо лучше. Структура — это тип, содержащий именованные поля. Например, мы можем представить круг таким образом:

```go
type Circle struct {
    x float64
    y float64
    r float64
}

```

Ключевое слово `type` вводит новый тип. За ним следует имя нового типа `Circle` и ключевое слово `struct`, которое говорит, что мы определяем структуру и список полей внутри фигурных скобок. Каждое поле имеет имя и тип. Как и с функциями, мы можем объединять поля одного типа:

```rust
type Circle struct {
    x, y, r float64
}
```

### **Инициализация**

Мы можем создать экземпляр нового типа `Circle` несколькими способами:

```go
var c Circle
// или
c := Circle{}
```

Подобно другим типам данных, будет создана локальная переменная типа `Circle`, чьи поля по умолчанию будут равны нулю (`0` для `int`, `0.0` для `float`, `""` для `string`, `nil` для указателей, …). Также, для создания экземпляра можно использовать функцию `new`.

```go
c := new(Circle)

```

Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (`*Circle`). Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения. Существует два способа сделать это. Первый способ:

```groovy
c := Circle{x: 0, y: 0, r: 5}

```

Второй способ — мы можем опустить имена полей, если мы знаем порядок в котором они определены:

```makefile
c := Circle{0, 0, 5}
```

### **Поля**

Получить доступ к полям можно с помощью оператора `.` (точка):

```
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5

```

Давайте изменим функцию `circleArea` так, чтобы она использовала структуру`Circle`:

```swift
func circleArea(c Circle) float64 {
    return math.Pi * c.r * c.r
}

```

В функции `main` у нас будет:

```llvm
c := Circle{0, 0, 5}
fmt.Println(circleArea(c))

```

Очень важно помнить о том, что аргументы в Go всегда копируются. Если мы попытаемся изменить любое поле в функции `circleArea`, оригинальная переменная не изменится. Именно поэтому мы будем писать функции используя указатели:

```swift
func circleArea(c *Circle) float64 {
    return math.Pi * c.r * c.r
}

```

И изменим `main`:

```llvm
c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))
```

### **Методы**

Несмотря на то, что программа стала лучше, мы все еще можем значительно её улучшить, используя метод — функцию особого типа:

```swift
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}

```

Между ключевым словом `func` и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора `.`:

```css
fmt.Println(c.area())

```

Это гораздо проще прочесть, нам не нужно использовать оператор `&` (Go автоматически предоставляет доступ к указателю на `Circle` для этого метода), и поскольку эта функция может быть использована только для `Circle` мы можем назвать её просто `area`.

Давайте сделаем то же самое с прямоугольником:

```go
type Rectangle struct {
    x1, y1, x2, y2 float64
}
func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}

```

В `main` будет написано:

```makefile
r := Rectangle{0, 0, 10, 10}
fmt.Println(r.area())
```

### **Встраиваемые типы**

Обычно, поля структур представляют отношения принадлежности (включения). Например, у `Circle` (круга) есть `radius` (радиус). Предположим, у нас есть структура `Person` (личность):

```go
type Person struct {
    Name string
}
func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}

```

И если мы хотим создать новую структуру `Android`, то можем сделать так:

```elm
type Android struct {
    Person Person
    Model string
}

```

Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями. Выглядят они так:

```elm
type Android struct {
    Person
    Model string
}

```

Мы использовали тип (`Person`) и не написали его имя. Объявленная таким способом структура доступна через имя типа:

```
a := new(Android)
a.Person.Talk()

```

Но мы также можем вызвать любой метод `Person` прямо из `Android`:

```
a := new(Android)
a.Talk()

```

Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.

Также мы можем при создании инициализировать нужные переменные:

```go
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}

```

Данная задача ориентирована на реальную работу с данными в формате JSON. Для решения мы будем использовать справочник ОКВЭД (Общероссийский классификатор видов экономической деятельности), который был размещен на web-портале data.gov.ru.

Необходимая вам информация о структуре данных содержится в файле structure-20190514T0000.json, а сами данные, которые вам потребуется декодировать, содержатся в файле data-20190514T0100.json. Файлы размещены в [нашем репозитории на github.com](https://github.com/semyon-dev/stepik-go/tree/master/work_with_json).

Для того, чтобы показать, что вы действительно смогли декодировать документ вам необходимо в качестве ответа записать сумму полей global_id всех элементов, закодированных в файле.

# **Строки (string)**

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать особые управляющие последовательности символов. Например, \n (перенос строки) или \t (символом табуляции).

Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:

- к строке применимы операции, применимые к массивам и срезам;
- чтобы изменить строку, необходимо создать новую строку;
- мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
- мы можем определить в строке подстроку.

```go
func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов.
	var s string = "Это строка"

	// Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы
	// занимают 2 байта, а пробел занимает 1 байт.
	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Посмотрим как взять подстроку
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	/*
		Попробуем изменить что-то встроке:
		s[3] = 12
		Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.
	*/

	// "Изменим строку", создав новую
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// А теперь проитерируемся по этой строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072

}
```

В заключение скажем, что строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):

```go
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```

### **Функции для работы со строками**

Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные:

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(
        // Содержится ли подстрока в строке
        strings.Contains("test", "es"),
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса
        strings.HasPrefix("test", "te"),
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"),
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"),
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5),
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"

        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"),
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"),
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"),
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
    )
}
```

Так как мы рассмотрели только основные функции мы рекомендуем ознакомиться с официальной документацией пакета "strings" - https://godoc.org/strings .

****Байтовые срезы ([]byte)****

Когда мы рассматривали строки, то говорили, что строки - это последовательность байт. Пришло время кратко рассмотреть этот тип данных. Кратко потому, что байтовый срез (последовательность байт) - это изменяемая последовательность чисел (тип byte соответствует типу uint8.), из чего мы делаем следующие выводы:

- байтовый срез можно изменять (в отличие от строки);
- к байтовому срезу применимо все, что применимо к массивам и срезам других типов (взятие среза, итерация);
- к отдельным байтам применимы операции, применимые к числам.

```go
func ExampleByteSlice() {
	// Используем тип string, который конвертируем в []byte,
	// чтобы не использовать абстрактные цифры
	bs := []byte("Это байтовый срез")

	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs)

	// Продемонстрируем, что байтовый срез можно изменить,
	// а затем напечатаем его в виде строки
	for i := range bs {
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
			continue
		}
		bs[i] = bs[i] - 1
	}

	fmt.Printf("Измененный байтовый срез в виде строки: %s", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Измененный байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ
}
```

Заканчивая разговор о байтовом срезе нужно сказать, что т.к. этот тип может хранить фактически любые данные и является изменяемым, то регулярно используется в стандартной библиотеке для совершенно разных целей. Строки же используются значительно реже.

## **Срезы рун ([]rune)**

Попробуем опять же кратко поговорить о том, что из себя представляет тип rune.

Думаю, что все слышали о кодировке Unicode, таблица, в которой собраны все символы из всех мировых систем письменности плюс разнообразные символы ударений и прочие диакритические знаки, управляющие коды наподобие символов табуляции и возврата каретки и многое другое. Каждому такому символу назначен стандартный номер — код символа Unicode (Unicode code point), или, в терминологии Go, руна (rune).

Когда мы говорили о типах string и []byte, то выяснили, что 1 символ может занимать более одного байта. Слегка упрощая мы можем сказать, что тип []rune - это последовательность на самом деле кодов символов, причем 1 символ состоит из 1 кода (тип rune соответствует типу int32).

Методы работы с типом []rune показаны в следующем примере (обратите внимание на тип используемых в примере кавычек, это не те же самые кавычки, что мы используем при работе со строками):

```go
func ExampleRune() {
	// Поступим также, как в работе с типом []byte
	rs := []rune("Это срез рун")

	// Итерируясь мы будем заменять символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' {
			rs[i] = '*'
		}
	}
	fmt.Printf("Измененнный срез в виде строки: %s\n", string(rs))

	// Output:
	// Измененнный срез в виде строки: Это с*ез *ун
}
```

## **Unicode**

Помимо пакета strings, есть некоторые полезные функции из пакета unicode для работы с символами.

```go
package main

import (
	"fmt"
	"unicode"
)

func main() {
    // функции ниже принимают на вход тип rune

    // проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
    // проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true
    // проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
    // проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
    // проверка символа на пробел
    // пробел это не только ' ', но и:
    //  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true

    // С помощью функции Is можно проверять на кастомный RangeTable:
    // например, проверка на латиницу:
 	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false

    // функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F
}
```

Если хотите ознакомиться подробнее с этим пакетом - советуем почитать [документацию](https://golang.org/pkg/unicode/).

## **Количество символов в строке**

Многие новички забывают что функция `len()` возвращает количество **байт** которое занимает строка, а не количество символов. Поэтому это будет работать только при использование латиницы и некоторых специальных символов ([ASCII](https://ru.wikipedia.org/wiki/ASCII)), так как они занимают 1 байт на 1 символ. А вот русские буквы уже занимают 2 байта на символ, мы можем это видеть в примере:

Для получения количества **символов** используйте `utf8.RuneCountInString()`

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	var en = "english"
	var ru = "русский"
	fmt.Println(len(en), len(ru))
	fmt.Println(utf8.RuneCountInString(en), utf8.RuneCountInString(ru))
}
```

Вывод будет такой:

```
7 14 // en -7 байтов, ru - 14 байтов
7 7 // а длина у строк одинаковая
```

# **Обработка ошибок**

Хороший код должен правильно реагировать на непредвиденные обстоятельства, такие как ввод некорректных данных пользователем, разрыв сетевого подключения или отказ дисков. *Обработка ошибок* — это процесс обнаружения ситуаций, когда ваша программа находится в неожиданном состоянии, а также принятие мер для записи диагностической информации, которая будет полезна при последующей отладке.

В отличие от других языков программирования, где разработчикам нужно обрабатывать ошибки с помощью специального синтаксиса (try catch/try except), ошибки в Go — это значения с типом `error`, возвращаемые функциями, как и любые другие значения. Для обработки ошибок в Go мы должны проверить ошибки, которые могут возвращать функции, решить, существует ли ошибка, а также принять надлежащие меры для защиты данных и сообщить пользователям или операторам, что произошла ошибка.

Самая простая обработка - это проверка ошибки на пустоту. Многие методы и функции в GO при вызове возвращают не только нужный результат, но и ошибку. К примеру: у нас есть функция которая делит число на другое число и ввод переменной.

```go
package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	fmt.Scan(&input)
	fmt.Println(divide(input, 5)) //Выведем результат
}

```

Однако, надо учесть, что пользователь может быть невнимательным и подать на вход все, кроме int, что может сломать нашу программу. Предотвратим это, используя специальную конструкцию:

```go
package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	_, err := fmt.Scan(&input) // функция Scan возвращает два параметра, но нам сейчас важно проверить только ошибку
	if err != nil {
		fmt.Println("Проверьте типы входных параметров")
	} else {
		fmt.Println(divide(input, 5)) //Выведем результат, если ошибок нет
	}
}
```

Теперь если наш пользователь введет переменную типа не int то он увидит нашу дружелюбную просьбу:

https://ucarecdn.com/f147ac46-1378-4c03-a506-6fdcd11c4bbf/

nil - это пустота (null в других языках)

Если переменная "err" не пустая - произошла ошибка, иначе - всё хорошо.

Не обрабатывать ошибки  - плохая практика, именно поэтому IDE (например Goland) всегда подскажет, что функция возвращает ошибку которую вы не обработали.

https://ucarecdn.com/bd964f91-afdd-458c-815e-563f3c8de99e/

## **Создание ошибок**

Стандартная библиотека предоставляет две встроенные функции для создания ошибок: `errors.New` и `fmt.Errorf`. Обе эти функции позволяют нам указывать настраиваемое сообщение об ошибке, которое вы можете отображать вашим пользователям.

`errors.New` получает один аргумент — сообщение об ошибке в виде строки, которую вы можете настроить, чтобы предупредить ваших пользователей о том, что пошло не так.

Попробуйте запустить следующий пример, чтобы увидеть ошибку, созданную с помощью `errors.New`, которая выполняет стандартный вывод:

```css
package main

import (
    "errors"
    "fmt"
)

func main() {
    err := errors.New("my error")
    fmt.Println("", err)
}
```

Мы использовали функцию `errors.New` из стандартной библиотеки для создания нового сообщения об ошибке со строкой `"barnacles"` в качестве сообщения об ошибке. Мы выполняли требование конвенции, используя строчные буквы для сообщения об ошибке, как показано в [руководстве по стилю для языка программирования Go](https://github.com/golang/go/wiki/CodeReviewComments#error-strings).

# **Оператор panic**

Оператор **panic** позволяет сгенерировать ошибку и выйти из программы:

```go
package main
import "fmt"

func main() {
    fmt.Println(divide(15, 5))
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
    if y == 0{
        panic("division by zero!")
    }
    return x / y
}
```

Оператору panic мы можем передать любое сообщение, которое будет выводиться на консоль. Например, в данном случае в функции divide, если второй параметр равен 0, то осуществляется вызов `panic("division by zero!")`.

В функции main в вызове `fmt.Println(divide(4, 0))` будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, которые идут после этого вызова, например, в данном случае это вызов `fmt.Println("Program has been finished")`, не будут выполняться. В этом случае мы получим следующий консольный вывод:

```
3panic: division by zero!
```

И в конце вывода будет идти диагностическая информация о том, где возникла ошибка.

# **Оператор defer**

Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:

```go
package main
import "fmt"

func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}

func finish(){
    fmt.Println("Program has been finished")
}
```

Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:

```
Program has been started
Program is working
Program has been finished

```

Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:

```go
package main
import  "fmt"

func main() {

    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}

func finish(){
    fmt.Println("Program has been finished")
}
```

Консольный вывод:

```
Program is working
Program has been started
Program has been finished
```

Дополнение: команда *defer* помещает вызов функции в стек. Поэтому они выполняются в очередности -LIFO (Last-In, First-Out)

**defer** запоминает значения переменных, переданных в функцию, на момент объявления defer, а не на момент его вызова. То есть условно

```go
a:=5

defer myFunc(a) // когда вызовется myFunc - будет передано значение 5, а не 7

a = 7
```

# **Отображения, по другому - map, карта**

Отображения - структура данных, неупорядоченная коллекция пар "ключ-значение", в которой все ключи различны, а значение, связанное с заданным ключом, можно получить, обновить или удалить независимо от размера карты (отображения).

Отображение в Go представляет собой ссылку на хеш-таблицу, а его тип записывается как map[K]V, где К и V являются типами его ключей и значений.

Все ключи в данном отображении имеют один и тот же тип, как и все значения имеют один и тот же тип, но тип ключей не обязан совпадать с типом значений. Тип ключа К должен быть сравниваемым с помощью оператора ==, чтобы отображение могло проверить, равен ли данный ключ одному из имеющихся в нем.

## **Создание отображений**

Объявление map выглядит так:

```go
var users map[string]int
// string - ключ, int - значения
```

**Но так делать опасно**, так мы не инициализировали его и при добавлении значений будут ошибки. (см. ниже)

Поэтому есть 2 более правильных способа создания отображений в Go:

```go
// с помощью встроенной функции make:
m1 := make(map[int]int)

// с помощью использования литерала отображения:
m2 := map[int]int{
    // Пары ключ:значение указываются при необходимости
    12: 2,
    1:  5,
}

fmt.Println(m1) // map[]
fmt.Println(m2) // map[1:5 12:2]
```

Почему мы не можем просто объявить отображение с помощью ключевого слова var? Объявляя переменную с использованием ключевого слова var, но не присваивая ей явно начальное значение, мы присваиваем ей нулевое значение. Отображение в Go - ссылка на хэш-таблицу, а нулевое значение ссылки nil. Попытавшись в дальнейшем добавить значение для определенного ключа мы получим ошибку "assignment to entry in nil map", которая приведет к панике:

```go
var m map[int]int
m[12] = 3
fmt.Println(m)

// Вывод (сработает паника):
// panic: assignment to entry in nil map
```

Конечно же мы можем использовать такое объявление когда нам не нужно вручную добавлять элементы, например просто присвоить результату из функции, но нужно быть крайне осторожным в таких случаях.

```go
var m map[int]int
m = someFunc()
fmt.Println(m)
// Второй вариант безопаснее
var m = map[int]int{}
m = someFunc()
fmt.Println(m)
```

## **Работа с отображениями**

Обратиться к элементам отображения можно с помощью обычной индексации:

```go
m := map[int]int{
	12: 2,
	1:  5,
}

fmt.Println(m[12]) // 2
```

Удаление осуществляется с помощью встроенной функции delete:

```go
m := map[int]int{
	12: 2,
	1:  5,
}

delete(m, 12) // Удаление элемента по ключу 12
fmt.Println(m) // map[1:5]
```

Все эти операции безопасны, даже если элемент в отображении отсутствует: при использовании ключа, которого нет в отображении, поиск возвращает нулевое значение соответствующего типа:

```go
m := make(map[int]int)

fmt.Println(m[12]) // 0

delete(m, 12)
fmt.Println(m) // map[]
```

В приведенном примере мы видим, что если ключ в отображении отсутствует, то при обращении к значению по ключу будет возвращено нулевое значение соответствующего типа. Особенно это критично, если согласно логике нашей программы такое нулевое значение может иметь место. Как же понять, что ключ в отображении присутствует? Мы можем воспользоваться тестом из следующего примера:

```go
m := map[int]int{
	1: 10,
}

if value, inMap := m[1]; inMap {
	fmt.Println(value) // 10
}

if value, inMap := m[2]; inMap {
	fmt.Println(value) // Условие не выполняется
}
```

Второе значение inMap - это логическое значение, показывающее, имеется ли данный элемент в отображении. Этой логической переменной часто дают имя ok.

Для перечисления всех пар "ключ-значение" в отображении мы используем циклы по диапазону, аналогичные тем, которые мы использовали для массивов и срезов. Последовательные итерации приведенного ниже цикла присваивают переменным key и value значения из очередной пары "ключ-значение" :

```go
for key, value := range mapName {
    fmt.Println(key, value)
}
```

Кроме того, Go позволяет применить к отображению функцию len, которая вернет количество пар "ключ-значение", хранящееся в отображении:

```go
m := map[int]int{
	1: 10,
	2: 20,
	3: 30,
}
fmt.Println(len(m)) // 3
```

# **Преобразование типов данных**

На своем пути разработчика вы будете часто встречаться с задачами, в которых нельзя без преобразования типов. Преобразование  одного типа может положительно сказаться как на удобстве разработки, так и на производительности самого приложения. А может быть вам просто нужно вызвать функцию которая принимает только определенный тип данных.

Поговорим о **Golang** с точки зрения типов. Это ****статически типизированный язык, понятнее говоря, типы данных в Go (и других статически типизированных языках) связаны с переменной, а не с ее значением. Вы уже усвоили, что в переменной типа int могут храниться только целые числа. Но Go позволяет преобразовывать целочисленные типы, числа с плавающей запятой, строки, байты и так далее.

# **Приведение целочисленных типов**

Выбор одного или другого типа в основном зависит от производительности, однако в некоторых случаях вам придется преобразовать один целочисленный тип в другой. Например, **Go** иногда автоматически генерирует числовые значения как int, а это может не соответствовать вашему входному значению. Если вы введете значение int32, вы не сможете использовать числа int и int32 в одном и том же математическом выражении, пока не преобразуете их типы данных соответствующим образом.

И так, преобразования между целыми числами делают очень просто. Вам нужно обернуть в скобки переменную которую вы хотите конвертировать и слева от скобок написать нужный тип, например:

Преобразование **int8** в **int32** делается таким образом:

```go
var index int8 = 15
var bigIndex int32
bigIndex = int32(index)

// Выведем:
fmt.Println(bigIndex)         // 15
fmt.Printf("%T \n", bigIndex) // int32

// По аналогии выше легко понять как конвертировать в другие типы:
var a int32 = 22
var b uint64
b = uint64(a)

// Выведем
fmt.Println(b)         // 22
fmt.Printf("%T \n", b) // uint64

```

**Примечание: %T - параметр функции Printf, позволяющий вывести тип переменной.**

**Важно:** Go позволяет преобразовывать типы с большим количеством бит в типы с меньшим количеством бит.

Сделать это можно вот так:

```go
var big int64 = 64

var little int8

little = int8(big)

fmt.Println(little) //64
```

**Однако**, при преобразовании целых чисел, может быть превышено максимальное значение для данного типа данных, и выполнится *перенос (потеря данных)*:

```go
var big int64 = 129
var little = int8(big)
fmt.Println(little)  //-127
```

Для того чтобы узнать какое максимальное значение мы можем положить в определенный тип воспользуемся константами из пакета math:

```go
fmt.Println(math.MaxInt8)   // 127
fmt.Println(math.MaxUint8)  // 255
fmt.Println(math.MaxInt16)  // 32767
fmt.Println(math.MaxUint16) // 65535
// ...
```

# **Приведение целых чисел и чисел с плавающей точкой**

Преобразование целого числа в число с плавающей точкой ничем не отличается от преобразования целого числа. Можно использовать встроенную конверсию, обернув `float64()` или `float32()` вокруг целого числа:

```go
var x int64 = 57
var y float64 = float64(x)
fmt.Print(y) // 57
```

**Преобразование чисел с плавающей точкой в целые числа**

Go может преобразовывать float в int. Но делает это с потерей точности. Синтаксис преобразования не меняется.

```go
var f float64 = 56.231
var i int = int(f)
fmt.Println(f) // 56.231
fmt.Println(i) // 56
```

**Числа, конвертируемые с помощью деления**

```
a := 5 / 2
fmt.Println(a) // 2
```

Если при делении используются числовые типы с плавающей точкой, тогда все остальные типы будут автоматически объявляться как числа с плавающей точкой:

```
a := 5.0 / 2
fmt.Println(a) //2.5
```

# **Конвертация строк в байты/rune и обратно**

Строка в Go это срез байтов, поэтому мы можем конвертировать байты в строку и наоборот:

```go
package main

import (
    "fmt"
)

func main() {
    a := "str"

    b := []byte(a)

    c := string(b)

    fmt.Println(a) // str

    fmt.Println(b) // [115 116 114] - побайтовый срез

    fmt.Println(c) // str
}
```

Первая строка вывода - значение переменной "a", вторая - ее побайтовый срез, третья - значение переменной "c", являющейся  результатом конвертации байтов в строку.

Тоже самое работает и со срезами типа **rune**:

```go
package main

import (
    "fmt"
)

func main() {
    a := "строка"

    b := []rune(a) // срез рун

    c := string(b)

    fmt.Println(a) // строка

    fmt.Println(b) // [1089 1090 1088 1086 1082 1072] - срез рун

    fmt.Println(c) // строка
}
```

# **Конвертация в строки**

Для начала рассмотрим конвертацию целых чисел в строки. **Golang** - язык со статической и строгой типизацией. Он не позволит вам сложить строку и число. Например напишем такой код:

```go
package main

import (
    "fmt"
)

func main() {
    user := "ученик"
    steps := 4

    fmt.Println("Поздравляю, " + user + "! Ты прошел " + steps + " шага по приведению типов.")
}
```

Мы получим ошибку во время компиляции:

`invalid operation: ("Поздравляю, " + user + "! Ты прошел ") + steps (mismatched types string and int)`

При конвертации чисел в строки очень удобно использовать пакет `strconv`, он обладает методом `Itoa`, превращающим числовое значение (int) переменной в строковое (string).

В теории звучит очень сложно, на деле - просто. Рассмотрим на примере.

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	a := strconv.Itoa(2020) // int -> string
	fmt.Printf("%T \n", a) // тип - string
	fmt.Println(a) // 2020
}
```

А теперь вернемся к примеру выше. Чтобы исправить прошлую ошибку - надо привести steps к строке.

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	user := "ученик"
	steps := 4

	fmt.Println("Поздравляю, " + user + "! Ты прошел " + strconv.Itoa(steps) + " шага по приведению типов.")
}

```

Да, в этом примере не обязательно использовать `strconv`, мы могли бы просто перечислить в Print все переменные как аргументы функции, но могут возникнуть ситуации где никак не обойтись без конвертации. Мы лишь показали как это делать.

**Интересное дополнение**, метод `Itoa` это всего-лишь обертка для `FormatInt`: (кусок исходного кода пакета `strconv`)

```go
// Itoa is equivalent to FormatInt(int64(i), 10).
func Itoa(i int) string {
	return FormatInt(int64(i), 10)
}
```

То-есть вызывая метод `Itoa` мы по сути вызываем `FormatInt` который принимает систему счисления в качестве 2 аргумента, но туда сразу передается - десятичная система счисления.

Но никто нам не мешает напрямую вызывать`FormatInt`, полезно если работаем с разными системами счисления:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// приставка '0x' означает что число в шестнадцатеричной системе счисления
	var a int64 = 0xB // 'B' в шестнадцатеричной это 11 в десятичной системе
	fmt.Println(strconv.FormatInt(a, 10)) // 11
	fmt.Println(strconv.FormatInt(a, 16)) // b
}

```

## **Конвертация целых беззнаковых чисел в строку**

По аналогии с `FormatInt` есть такой метод как `FormatUint`, пример:

```go
var a uint64 = 10101
res := strconv.FormatUint(a, 10)
fmt.Println(res) // 10101
```

### **Конвертация чисел с плавающей запятой в строку**

Для этого есть функция `FormatFloat`:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var a float64 = 1.0123456789

	// 1 параметр - число для конвертации
	// fmt - форматирование
	// prec - точность (кол-во знаков после запятой)
	// bitSize - 32 или 64 (32 для float32, 64 для float64)
	fmt.Println(strconv.FormatFloat(a, 'f', 2, 64)) // 1.01

	// если мы хотим учесть все цифры после запятой, то можем в prec передать -1
	fmt.Println(strconv.FormatFloat(a, 'f', -1, 64)) // 1.0123456789

	// Возможные форматы fmt:
	// 'f' (-ddd.dddd, no exponent),
	// 'b' (-ddddp±ddd, a binary exponent),
	// 'e' (-d.dddde±dd, a decimal exponent),
	// 'E' (-d.ddddE±dd, a decimal exponent),
	// 'g' ('e' for large exponents, 'f' otherwise),
	// 'G' ('E' for large exponents, 'f' otherwise),
	// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or
	// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).
	var b float64 = 2222 * 1023 * 245 * 2 * 52
	fmt.Println(strconv.FormatFloat(b, 'e', -1, 64)) // 5.791874088e+10
}

```

Так же можно использовать пакет "fmt". Он обладает удобным методом Sprintf. Вот [шпаргалка](https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/) по всему пакету.

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println(fmt.Sprint(20.19)) // Краткая форма

    a := 20.20
    fmt.Println(fmt.Sprintf("%f", a)) // Полная форма
}
```

**Внимание! Использовать fmt для конвертации нежелательно из-за того что производительность ниже по сравнению с strconv.**

## **Конвертация bool в string**

**Тут все просто:**

```go
var a = true
res := strconv.FormatBool(a)
fmt.Println(res)     	// true
fmt.Printf("%T", res)   // string
```

# **Конвертация строк в другие типы**

Рассмотрим для начала конвертацию **строк в целые числа** на примерах:

```go
package main

import (
    "fmt"
)

func main() {
    foo := "10"
    bar := "15"
    baz := foo - bar
    fmt.Println(baz)
}
```

Если вы попробуете запустить этот код, то вы столкнетесь с ошибкой:

```go
invalid operation: foo - bar (operator - not defined on string)
```

Встретите вы её, так как операнд вычитания не является действительным для строк. Это можно исправить, использовав метод пакета `strconv` - `Atoi`:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	foo := "10"
	bar := "15"
	barInt, err := strconv.Atoi(bar)
	if err != nil {
		panic(err)
	}
	fooInt, err := strconv.Atoi(foo)
	if err != nil {
		panic(err)
	}
	baz := barInt - fooInt
	fmt.Println(baz) //5
}

```

### ***Важно: при конвертации строки, которая не содержит в себе число - ваша программа выдаст вам ошибку***

```go
strconv.Atoi: parsing "not a number": invalid syntax

```

Так как метод Atoi кроме результата возвращает еще и ошибку, то мы можем легко это проверить (вспоминаем урок 2 модуля про ошибки):

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "323str"
	result, err := strconv.Atoi(s)
	if err != nil {
		fmt.Println(err) // strconv.Atoi: parsing "323str": invalid syntax
	} else {
		fmt.Println(result)
	}
}
```

## **Конвертация string в float с помощью метода `ParseFloat`:**

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "23.23456"
	// как и в прошлом шаге, здесь 2 параметр - bitSize
	// bitSize - 32 или 64 (32 для float32, 64 для float64)
	// но нужно понимать что метод все равно вернет float64
	result, err := strconv.ParseFloat(s, 64)
	if err != nil {
		panic(err)
	}
	fmt.Println(result)        			 // 23.23456
	fmt.Printf("%T \n", result)  // float64

	// Конкретный пример для разных bitSize:
	s = "1.0000000012345678"
	//  не будем обрабатывать ошибки в примерах, но на практике так не делайте ;)
	result32, _ := strconv.ParseFloat(s, 32)
	result64, _ := strconv.ParseFloat(s, 64)
	fmt.Println("bitSize32:", result32)  // вывод 1 (не уместились)
	fmt.Println("bitSize64:", result64)  // вывод  1.0000000012345678
}
```

**Полезно знать!**

Так же по аналогии с примерами выше есть методы ParseUint, ParseInt, ParseBool.

**Кстати, метод** `Atoi` эквивалентен `ParseInt(s, 10, 0), конвертированному в int.`

Примеры:

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	s := "-12345"
	res, err := strconv.ParseInt(s, 10, 64)
	if err != nil { // не забываем проверить ошибку
		panic(err)
	}

	fmt.Println(res) // -12345

	s = "12345"
	res2, err := strconv.ParseUint(s, 10, 64)
	if err != nil {  // не забываем проверить ошибку
		panic(err)
	}
	fmt.Println(res2) // 12345
}

```

## **Конвертация string в bool**

```go
s := "true"
res, err := strconv.ParseBool(s)
if err != nil { // не забываем проверить ошибку
	panic(err)
}
fmt.Println(res)      // true
fmt.Printf("%T", res)  // bool
```

# A**нонимные функции**

## **Функции как объекты первого класса**

В Go функции являются объектами первого класса, это значит, что в этом языке программирования функцию можно передать в качестве аргумента другой функции или же вернуть функцию в качестве значения. Подробнее об этом можно почитать в Википедии [здесь](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0) и [здесь](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0).

Рассмотрим передачу функции в качестве аргумента другой функции на примере Map из уже знакомого нам пакета strings. Эта функция выглядит так:

```go
func Map(mapping func(rune) rune, s string) string
```

Функция Map в качестве первого аргумента получает функцию вида func (rune) rune, производящей какие-то действия с символом Unicode и возвращающей в качестве результата символ Unicode. Из [описания этой функции](https://pkg.go.dev/strings?tab=doc#Map) следует, что переданная в качестве аргумента функция будет применена к каждому символу строки, переданной в качестве второго аргумента функции Map, получившаяся строка будет возвращена в качестве результата.

Создадим такую функцию:

```go
func invert(r rune) rune {
	// Если буква строчная, то она возвращается заглавной
	if unicode.IsLower(r) {
		return unicode.ToUpper(r)
	}
	// Иначе возвращается строчной
	return unicode.ToLower(r)
}
```

А теперь используем ее:

```go
func ExampleFirstClassFunctionArgument() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(invert, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```

Аналогично мы можем вернуть функцию в качестве значения:

```go
func returnFunction() func(rune) rune {
	return invert
}
```

## **нонимная функция**

Ранее, объявляя функцию, мы давали этой функции имя. Такое объявление можно сделать только за пределами других функций (на уровне пакета). Объявляя функцию на уровне пакета мы имеем возможность написать для такой функции необходимые тесты и удобно изменять ее реализацию. В этом нам в т.ч. помогает определенный уровень изоляции области видимости такой функции.

Однако в ряде случаев нам необходимо выполнить определенную задачу на месте, возможно предоставив функции доступ к области видимости вызывающей функции, как быть в этом случае? Язык Go позволяет нам использовать анонимные функции в любом выражении. Литерал такой функции записывается как объявление функции, но без имени после ключевого слова func.

Давайте немного изменим пример с функцией Map из пакета strings:

```go
func ExampleFunctionWithoutName() {
	src := "aBcDeFg"
	test := "AbCdEfG"

	// Обратите внимание, что скобки после имени функции используются только при ее вызове
	src = strings.Map(func(r rune) rune {
		if unicode.IsLower(r) {
			return unicode.ToUpper(r)
		}
		return unicode.ToLower(r)
	}, src)

	fmt.Printf("Инвертированная строка: %s. Результат: %v.\n", src, src == test)

	// Output:
	// Инвертированная строка: AbCdEfG. Результат: true.
}
```

В этом примере мы передали функции Map в качестве аргумента анонимную функцию, общий результат работы от этого не изменился.

Анонимные функции могут быть объявлены в другой функции, присвоены переменной или вызваны на месте:

```go
func ExampleUseNoNameFunction() {
	// Присваиваем переменной значение анонимной функции
	fn := func(a, b int) int { return a + b }

	// Выполняем анонимную функцию на месте
	// Обратите внимание на использование скобок при вызове функции
	func(a, b int) {
		fmt.Println(a + b)
	}(12, 34)

	fmt.Println(fn(17, 15))

	// Output:
	// 46
	// 32
}
```

В примере мы присвоили переменной fn функцию вида func(int, int) int, затем выполнили другую анонимную функцию, а затем выполнили функцию, присвоенную переменной fn. Обратите внимание на использование скобок в примерах - вызов функции требует наличия скобок, в которых указываются передаваемые функции аргументы (если аргументы не передаются - скобки пустые).

## О**бласть видимости анонимной функции. Замыкание**

В отличие от именованной функции, функция анонимная имеет доступ к окружению, в котором она была объявлена (в некоторых случаях объявление и вызов анонимной функции происходит одновременно):

```go
func externalFunction() func() {
	text := "TEXT"

	return func() {
		fmt.Println(text)
	}
}

func ExampleEnvironment() {
	fn := externalFunction()
	fn()

	// Output:
	// TEXT
}
```

Когда анонимная функция использует переменные, объявленные за ее рамками, ее называют замыканием. В приведенном примере мы объявили именованную функцию externalFunction, в которой объявляется переменная text. В качестве значения функция externalFunction возвращает замыкание - анонимную функцию, которая имеет доступ к переменной text, объявленной за ее пределами. Затем мы присвоили переменной fn результат выполнения функции externalFunction. Теперь fn - функция, мы вызываем ее, тем самым печатаем значение переменной text.

Усложним пример:

```go
func ExampleClosure() {
	fn := func() func(int) int {
		count := 0
		return func(i int) int {
			count++
			return count * i
		}
	}()

	for i := 1; i <= 5; i++ {
		fmt.Println(fn(i))
	}

	// Output:
	// 1
	// 4
	// 9
	// 16
	// 25
}
```

Здесь мы не просто печатаем значение переменной, но и изменяем его.

## **Отложенный вызов анонимной функции**

Мы уже говорили про defer в 2 модуле, напомним вам. Go позволяет отложить вызов внутренней функции до завершения функции внешней. Делается это с помощью ключевого слова defer перед вызовом функции. Отложенные функции выполняюся в обратном порядке (LIFO):

```go
func ExampleDefer1() {
	defer func() { fmt.Println(1) }()

	defer func() { fmt.Println(2) }()

	defer func() { fmt.Println(3) }()

	// Output:
	// 3
	// 2
	// 1
}
```

С помощью отложенного вызова часто закрываются файлы и соединения, а также осуществляется обработка паники в работе функции, при этом используются возможности анонимных функций.

Как вы знаете, возбуждение аварии осуществляется вызовом функции panic(), которой в качестве аргумента передается любой требуемый объект. Восстановление же после аварии осуществляется вызовом функции recover(), возвращающей переданный функции panic() аргумент. При этом функция recover() может быть обработана, если ее вызов отложен до возникновения аварии:

```go
func someFuncWithPanic() (err error) {
	defer func() {
		// отложенный вызов анонимной функции, проверяющей, что работа функции завершена
		// без ошибок. Если функция recover() возвращает что угодно кроме nil, значит в ходе
		// выполнения функции возникла паника.
		if e := recover(); e != nil {
			// Здесь происходит приведение интерфейса (об этом мы расскажем буквально в
			// следующем уроке. Результат приведения присваивается переменной err типа error
			// которая уже объявлена при самом вызове функции someFuncWithPanic.
			err = e.(error)

			// после этого анонимная функция завершает свою работу, паника обработана,
			// переменная err, в которой содержится информации о возникшей панике,
			// возвращается как результат выполнения функции.
		}
	}()

	panic(errors.New("fatal error"))
}

func ExamplePanicRecover() {
	if err := someFuncWithPanic(); err != nil {
		fmt.Println(err)
	}

	// Output:
	// fatal error
}
```

# **Интерфейсы**

До этого момента мы, в основном, имели дело с вполне конкретными типами: простыми - числами, строками, байтами, составными - массивы и срезы, структуры и отображения. Интерфейсы представляют собой новый - абстрактный тип данных в Go.

Интерфейс представляет из себя контракт, определяющий методы, которым обязан обладать объект, удовлетворяющий интерфейсу. Не очень понятно? Попробуем раскрыть эту тему таким образом, чтобы не просто разобраться с понятием интерфейса, но и научиться применять эти знания на практике.

## **Объявление интерфейса**

Интерфейсы, как и другие типы в Go, объявляются с помощью ключевого слова type, за которым следует имя объявляемого типа, а за ним - базовый тип (в нашем случае - interface). В фигурных скобках указаны имена и описания методов, которые должен иметь объект, чтобы "удовлетворять" данному интерфейсу. Реализация методов может быть совершенно разной, важно само наличие метода с соответствующим описанием (принимаемые аргументы и возвращаемые значения).

Посмотрим как объявляется интерфейс на примере пакета [io](https://pkg.go.dev/io?tab=doc) стандартной библиотеки:

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
```

Объекты, удовлетворяющие интерфейсу io.Reader, имеют метод Read, который получает срез байт (буфер, в который производится чтение) в качестве аргумента, а возвращает количество прочитанных байт и сообщение об ошибке. Интерфейс io.Writer делает все наоборот: его метод Write получает срез байт (буфер, из которого производится чтение), возвращает количество записанных байт и сообщение об ошибке.

Ничего большего интерфейс не определяет. Тип реализует интерфейс путем реализации всех его методов.

## **Использование интерфейса**

Решим реальную задачу с использованием интерфейсов, а параллельно ответим на вопрос в [комментариях](https://stepik.org/lesson/230630/step/8?unit=203151) к задаче в рамках этого курса. Часть кода в примерах будет опущена. Итак, проблема в задаче возникла в чтении 2х строк с использованием пакета [bufio](https://pkg.go.dev/bufio?tab=doc), вот 2 решения:

```go
var str1, str2 string

/*
 * Данное решение работало на локальной машине,
 * но на платформе Stepik вторая строка считывалась пустой
 */
str1, _ = bufio.NewReader(os.Stdin).ReadString('\n')
str2, _ = bufio.NewReader(os.Stdin).ReadString('\n')

/*
 * Данное решение работало и на локальной машине и на платформе
 * Stepik. Разница в том, что в первом решении объект bufio.Reader
 * создается дважды.
 */
r := bufio.NewReader(os.Stdin)
str1, _ = r.ReadString('\n')
str2, _ = r.ReadString('\n')
```

Функция bufio.NewReader принимает в качестве аргумента как раз интерфейс io.Reader, в примере в качестве аргумента передается os.Stdin - стандартный ввод (файл). Это значит, что мы можем передать данной функции в качестве аргумента что-то иное, что можем контролировать лучше, чем стандартный ввод пользователя с клавиатуры. Используем буфер из пакета bytes, который удовлетворяет интерфейсам io.Reader и io.Writer:

```go
// Объявление переменных str1, str2 опущено

func fn1() {
	buf := bytes.NewBufferString("string1\nstring2\n")
	fmt.Printf("Размер буфера до чтения первой строки: %d\n", buf.Len()) // Размер буфера до чтения первой строки: 16

	str1, _ = bufio.NewReader(buf).ReadString('\n')
	fmt.Printf("Размер буфера после чтения первой строки: %d\n", buf.Len()) // Размер буфера после чтения первой строки: 0
	str2, _ = bufio.NewReader(buf).ReadString('\n')

	fmt.Println(str1, str2) // string1
}

func fn2() {
	buf := bytes.NewBufferString("string1\nstring2\n")
	fmt.Printf("Размер буфера до чтения первой строки: %d\n", buf.Len()) // Размер буфера до чтения первой строки: 16

	r := bufio.NewReader(buf)
	str1, _ = r.ReadString('\n')
	fmt.Printf("Размер буфера после чтения первой строки: %d\n", buf.Len()) // Размер буфера после чтения первой строки: 0
	fmt.Printf("Размер буфера bufio.Reader: %d\n", r.Buffered()) // Размер буфера bufio.Reader: 8
	str2, _ = r.ReadString('\n')

	fmt.Println(str1, str2) // string1 ... string2
}
```

Дебагер и чтение кода помогли в дальнейшем разобраться с происходящим, но все началось с тестирования, когда вместо чтения со стандартного ввода мы использовали другой объект, реализующий тот же интерфейс. Если кто-то не понял, как и что произошло в разборе: bufio.Reader имеет свой буфер, в который читает байты из переданного ему io.Reader. Поэтому когда в первом случае мы использовали два bufio.Reader, второй ничего уже прочитать не мог - все было сохранено в буфере первого bufio.Reader.

Если продолжить разговор об интерфейсах io.Reader и io.Writer мы увидим, что эти интерфейсы реализуют: буферы, файлы, сетевые соединения, кодеры и декодеры и пр. Написав один раз функцию для чтения или записи мы, в конечном итоге, сможем использовать ее в десятках различных ситуаций: прочитать не из командной строки, а из сетевого соединения, а записать не на стандартный вывод, а в базу данных.

## **Пустой интерфейс**

Интерфейс, который не содержит ни одного метода называется пустым интерфейсом: interface{}. Пустой интерфейс может содержать значение любого типа. Пустые интерфейсы используются в коде, где необходимо работать со значениями неизвестного типа. Например, `fmt.Print()` принимает любое количество аргументов типа interface{}.

## **Встраивание интерфейса**

Стиль программирования на Go предполагает, что чем более четко мы сформулируем задачу, тем меньше вероятность возникновения ошибки. Таким образом (я продолжу использовать для примера интерфейсы из пакета io), если мы хотим использовать функцию лишь для чтения данных, то разумно использовать в качестве аргумента интерфейс io.Reader, а если для записи, то io.Writer.

Вместе с тем, Go позволяет нам совмещать интерфейсы, чтобы показать, что объект должен удовлетворять обоим интерфейсам. Это реализуется через создание нового интерфейса, в который требуемые нам интерфейсы встраиваются:

```go
type ReadWriter interface {
    Reader  // это io.Reader
    Writer  // это io.Writer
}
```

Таким образом Go будет проверять, что у объекта есть методы обязательные для обоих интерфейсов: Read и Write.

*Обратите внимание на используемые имена интерфейсов: в Go считается правильным называть интерфейс через имя его методов с добавлением суффикса -er, а если таких методов несколько, использовать имена всех методов.*

## **Приведение типа**

Приведение типа позволяет нам получить внутреннее значение интерфейса, в полной мере это реализуется следующим образом:

```go
// Конструкция приведения типа:
// t, ok := i.(T)

// Пример:
var i interface{} = 12

if v, ok := i.(int); ok {
	fmt.Println(v+12) // Суммирование не произойдет, если ok == false
}
```

Здесь t значение, приведенное к типу T, а i - исходное значение интерфейсного типа. ok - логическое значение, показывающее успешность приведения типа: true - все удачно, false - использование t приведет к панике. Значение ok может быть опущено, но будьте аккуратны с этим.

Но что делать, если мы не знаем типа объекта, лежащего внутри интерфейса? Тогда мы можем воспользоваться конструкцией, называемой переключателем типов, выглядит она следующим образом:

```go
switch v := i.(type) {
	case T1:
		...
	case T2, T3:
		...
	default:
		...
}
```

Возьмем теперь такой пример:

```go
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Println("Умножим на 2:", v*2)
	case string:
		fmt.Println(v + " golang")
	default:
		fmt.Printf("Я не знаю такого типа %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```

Вывод будет таким:

```
Умножим на 2: 42
hello golang
Я не знаю такого типа bool!
```

## **Интерфейс error**

В Go довольно много интерфейсов, применяемых повсеместно. Безусловно, наиболее распространенный среди них, это интерфейс error:

```go
type error interface {
    Error() string
}
```

Это знание позволяет нам создавать свои собственные типы ошибок, хранящие требуемые нам сведения о возникшей проблеме. Если же нам достаточно базовой реализации стандартной библиотеки, мы можем использовать пакеты [errors](https://pkg.go.dev/errors) или [fmt](https://pkg.go.dev/fmt).

### **Типы ошибок. Создание собственного типа ошибки**

В ряде случаев нам может быть не достаточно информации об ошибке в виде строки, и мы хотим добавить в нее какой-то контекст. В этом случае мы можем создать собственный тип, удовлетворяющий интерфейсу error. Допустим функция получает в качестве аргумента строку, которая не должна содержать цифр, а если это не так мы должны прервать обработку и вернуть в качестве контекста позицию в строке, на которой обнаружена цифра:

```go
package main

import (
	"fmt"
	"unicode"
)

type customError uint

func (c customError) Error() string {
	return fmt.Sprintf("цифра, индекс %d", c)
}

func errorInString(str string) error {
	// Полезная работа со строкой проигнорирована
	for i, s := range str {
		if unicode.IsDigit(s) {
			return customError(i)
		}
	}
	return nil
}

func main() {
	err := errorInString("string1string")
	if err != nil {
		fmt.Printf("Ошибка обработана: %v\n", err)
	}
	if cError, ok := err.(customError); ok {
		fmt.Printf("Контекст: %d\n", cError)
	}

	// Output:
	// Ошибка обработана: цифра, индекс 6
	// Контекст: 6
}
```

В примере мы создали свой тип ошибки, вернули его, привели его тип из интерфейса и получили требуемый нам контекст. Изучая стандартную библиотеку вы найдете примеры таких специальных ошибок. Для примера ошибка EOF из пакета io (EndOfFile). Но только что продемонстрированный способ обработки ошибок был принят в Go до версии 1.13, в настоящее время стандартная библиотека Go предоставляет более серьезные возможности для работы с ошибками.

## **Интерфейс Stringer**

В заключение рассмотрим еще один распространенный интерфейс стандартной библиотеки fmt.Stringer:

```go
type Stringer interface {
	String() string
}
```

Функция String возвращает текстовое представление объекта: функции из пакета fmt проверяют, удовлетворяет ли переданный функции аргумент интерфейсу Stringer, и если удовлетворяет - он выводится на печать в заданном формате. Посмотрим пример из пакета fmt:

```go
type Animal struct {
	Name string
	Age  uint
}

func (a Animal) String() string {
	return fmt.Sprintf("%v (%d)", a.Name, a.Age)
}

func ExampleStringer() {
	a := Animal{
		Name: "Gopher",
		Age:  2,
	}
	fmt.Println(a)

	// Output: Gopher (2)
}
```

# **Работа с файлами**

```go
package main

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func mywalkFunc(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err
	}
	if info.IsDir() {
		return nil
	}
	if strings.Contains(info.Name(), "file") {
		if err := ReadDataInfile(path); err != nil {
			fmt.Printf("Error reading file")
		}
		return nil
	} else {
		return nil
	}
}
func ReadDataInfile(path string) error{
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	buf := bufio.NewReader(file)
	defer file.Close()
	r := csv.NewReader(buf)
	data, err := r.ReadAll()
	if err != nil {
		return err
	}
	if len(data) == 10{
		fmt.Print(data[4][2])
	}

	
	
	return nil
}

func main() {
	const root = "./task"
	if err := filepath.Walk(root, mywalkFunc); err != nil {
		fmt.Printf("Error : %v ", err)
	}
}
//вторая задача из этого раздела где надо было брать файл из гитхаба
package main

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strings"
)

func ReadDataInfile(path string) error{
	file, err := os.Open(path)

	if err != nil {
		return err
	}
	buf := bufio.NewReader(file)

	defer file.Close()

	r := csv.NewReader(buf)
	
	for i := 0; i < 1; i++{
		row, err := r.Read()
		if err != nil && err != io.EOF {
			return err
		}
		rows := strings.Split(row[i], ";")
		for j := 0; j< len(rows); j++ {
			if rows[j] == "0"{
				fmt.Print(j)
			}
		}
	}

	return nil
}

func main() {
	const root = "./task.data"
	if err:= ReadDataInfile(root); err != nil {
		fmt.Print(err)
	}
	
}
```

Go предоставляет множество методов для работы с ресурсами операционной системы. Выбор метода зачастую зависит от требующей решения задачи. Раскрыть все возможные методы, во-первых, очень сложно, а, во-вторых, этот урок бы очень сильно затянулся. Как следствие, в этом уроке мы попробуем обозначить основные возможности и пакеты их реализующие, если вы захотите получить больше информации о работе с файлами, то обратитесь к документации самостоятельно. И помните, лучшее изучение это практика, так что экспериментируйте с файлами локально.

## **io/ioutil**

Пакет [io/ioutil](https://golang.org/pkg/io/ioutil/) предоставляет скромные, но наиболее востребованные возможности по чтению и записи файлов. Вот практически все содержащиеся в пакете функции:

```go
func ReadFile(filename string) ([]byte, error)

func WriteFile(filename string, data []byte, perm os.FileMode) error
```

Из сигнатуры этих функций все должно быть предельно ясно: функции реализуют чтение и запись файла, данные считываются / записываются в формате байтового среза. Единственное, что может быть не так очевидно, это параметр perm типа os.FileMode – это права доступа к файлу в битовом формате, знакомом всем, кто знаком с операционными системами *nix.

Следующая функция, которую мы можем использовать:

```go
func ReadAll(r io.Reader) ([]byte, error)
```

Здесь в качестве аргумента передается не имя файла, а объект типа io.Reader, соответственно функция может читать данные из всех объектов, удовлетворяющих указанному интерфейсу: в т.ч. сетевые соединения и буферы:

```go
b := bytes.NewReader([]byte("Данные в объекте io.Reader"))

data, err := ioutil.ReadAll(b)
if err != nil {
	// ...
}

fmt.Printf("%s\n", data) // Данные в объекте io.Reader
```

Последняя функция позволяет получить информацию о содержании директории:

```go
func ReadDir(dirname string) ([]os.FileInfo, error)
```

Не думаю, что в этом вопросе могут возникнуть какие-то проблемы, поэтому просто приведу ряд примеров:

```go
dataForFile := []byte("Тестовая строка, предназначенная для записи в файл")

// Создаем новый файл и записываем в него данные dataForFile
if err := ioutil.WriteFile("test.txt", dataForFile, 0600); err != nil {
	...
}

// Читаем данные из того же файла
dataFromFile, err := ioutil.ReadFile("test.txt")
if err != nil {
	...
}

// Сравниваем исходные данные с записанными в файл и прочитанными из него
fmt.Printf("dataForFile == dataFromFile: %v\n", bytes.Equal(dataFromFile, dataForFile))

// Изучаем содержимое директории
filesFromDir, err := ioutil.ReadDir(".")
if err != nil {
	...
}

for _, file := range filesFromDir {
	// Проходим по всем найденным файлам и печатаем их имя и размер
	fmt.Printf("name: %s, size: %d\n", file.Name(), file.Size())
}

// Output:
// dataForFile == dataFromFile: true
// name: main.go, size: 727
// name: test.txt, size: 93
```

## **os**

Следующий пакет, который мы просто обязаны рассмотреть, это пакет [os](https://golang.org/pkg/os/). Он содержит огромный набор высокоуровневых инструментов для работы с файлами (и не только).

Для начала мы должны отметить, что рассматриваемый пакет сам не предоставляет удобных инструментов для чтения и записи в файл, хотя теоретически чтение и запись возможны. Центром пакета является объект os.File, который реализует ряд интерфейсов, в т.ч. Reader и Writer. Таким образом для удобной работы с данным типом нам может потребоваться что-то еще, например для чтения всего файла может быть использована функция ReadAll из ранее рассмотренного пакета io/ioutil. Для создания рассматриваемого объекта мы можем использовать ряд предлагаемых пакетом функций:

```go
func Create(name string) (*File, error) // создание файла с именем name

func Open(name string) (*File, error) // открытие файла с именем name
```

Данный объект имеет ряд методов, позволяющих вернуть имя файла, изменить права доступа или владельца файла. Нас же, прежде всего, будет интересовать метод Close(), который должен быть вызван при закрытии файла, чтобы освободить занятые нашей программой ресурсы операционной системы. Чтобы быть уверенными, что файл будет закрыт, а ресурсы освобождены даже в случае критической непредвиденной ошибки, рекомендуется сразу после проверки, что файл создан / открыт запланировать его закрытие с помощью оператора отложенного вызова defer:

```
f, err := os.Open("fileName")
if err != nil {
	...
}
defer f.Close()
```

С имеющимися методами данного типа вы можете ознакомиться в документации, примеры же работы с этим объектом мы приведем в следующем шаге, когда рассмотрим более удобные способы работы с этим типом.

Переименование и удаление файлов делается через функции Rename и Remove:

```go
// создаем файл
os.Create("text.txt")
// переименовываем файл
os.Rename("text.txt", "new_text.txt")
// удаляем файл
os.Remove("new_text.txt")
// кстати, os позволяет работать не только с файлами
// выходим из программы:
os.Exit(0)
```

Так же мы можем получать информацию файлов и сравнивать их:

```go
file1, _ := os.Create("text.txt")
file2, _ := os.Create("text.txt")
info1, _ := file1.Stat() // функция Stat возвращает информацию о файле и ошибку
info2, _ := file2.Stat()
fmt.Println(os.SameFile(info1, info2)) // true

// вот что мы можем получить из FileInfo:
// A FileInfo describes a file and is returned by Stat and Lstat.
type FileInfo interface {
	Name() string       // base name of the file
	Size() int64        // length in bytes for regular files; system-dependent for others
	Mode() FileMode     // file mode bits
	ModTime() time.Time // modification time
	IsDir() bool        // abbreviation for Mode().IsDir()
	Sys() interface{}   // underlying data source (can return nil)
}
```

Также существует удобная функция WriteString у файлов которая записывает строки в конце файла. Например, нужно открыть существующий файл с какой-то информацией и записать, не затрагивая старую.

```go
file1, _ := os.Create("text.txt")
file1.WriteString("1 строка \n")
file1.WriteString("2 строка \n")
file1.Close()

// внутри файла будет:
// 1 строка
// 2 строка

```

*К сожалению, в рамках платформы Stepik мы не можем предложить вам задания, которые покажут все возможности пакета os: создание и изменение директорий, прав доступа, изменения владельца файла и пр., к тому же эти задачи выходят за рамки данного курса. Однако, если мы в дальнейшем найдем способ создать тестовые задания для этих возможностей, то расширим данный раздел, чтобы раскрыть возможности стандартной библиотеки в этой сфере.*

## **bufio**

Пакет [bufio](https://golang.org/pkg/bufio/) предоставляет нам ряд инструментов для удобного чтения и записи информации из объектов, удовлетворяющих интерфейсам io.Reader и io.Writer. Нас в этом вопросе прежде всего будут интересовать типы bufio.Reader, bufio.Writer и bufio.Scanner. Но перед тем как перейти к рассмотрению данных типов сделаем одно замечание (мы уже говорили об этом раньше в разделе об интерфейсах): объекты в пакете bufio имеют собственный буфер, позволяющий им реализовать дополнительные методы по сравнению с интерфейсами io.Reader и io.Writer, это необходимо учитывать в работе. Если вы не помните, о чем шла речь, вернитесь ненадолго к приведенному в том разделе примеру.

### **bufio.Reader**

Данный тип создается с помощью функций:

```go
func NewReader(rd io.Reader) *Reader // создает Reader со стандартным буфером 4096 байт

func NewReaderSize(rd io.Reader, size int) *Reader // создает Reader с произвольным буфером
```

Рассмотрим некоторые из методов bufio.Reader и примеры работы:

```go
file, err := os.Open("test.txt")
if err != nil {
	...
}
defer file.Close()

rd := bufio.NewReader(file)

buf := make([]byte, 10)
n, err := rd.Read(buf) // читаем в buf 10 байт из ранее открытого файла
if err != nil && err != io.EOF {
	// io.EOF не совсем ошибка - это состояние, указывающее, что файл прочитан до конца
	...
}
fmt.Printf("прочитано %d байт: %s\n", n, buf) // прочитано 10 байт: bufio ...

s, err := rd.ReadString('\n') // читаем данные до разрыва абзаца ('\n')
fmt.Printf("%s\n", s)         // ... здесь будет строка
```

bufio.Reader позволяет читать данные по байтам, рунам, строкам и пр., указывать символ, на котором необходимо прекратить чтение. Когда данные будут прочитаны до конца, метод вернет ошибку io.EOF.

### **bufio.Writer**

bufio.Writer создан для записи в объекты, удовлетворяющие интерфейсу io.Writer, но предоставляет ряд более высокоуровневых методов, в частности метод WriteString(s string):

```go
file, err := os.Create("test.txt")
if err != nil {
	...
}
defer file.Close()

w := bufio.NewWriter(file)
n, err := w.WriteString("Запишем строку")
if err != nil {
	...
}
fmt.Printf("Записано %d байт\n", n) // Записано 27 байт

// bufio.Writer имеет собственный буфер, чтобы быть уверенным, что данные точно записаны,
// вызываем метод Flush()
w.Flush()
```

Как вы уже поняли, создается объект функцией NewWriter(w io.Writer).

### **bufio.Scanner**

bufio.Scanner создан для построчного чтения данных. Создается он функцией NewScanner(r io.Reader), посмотрим, как работает этот тип:

```go
file, err := os.Open("test.txt")
if err != nil {
	panic(err)
}
defer file.Close()

s := bufio.NewScanner(file)

// Я заранее записал в файл 5 цифр, каждую на новой строке
for s.Scan() { // возвращает true, пока файл не будет прочитан до конца
	fmt.Printf("%s\n", s.Text()) // s.Text() содержит данные, считанные на данной итерации
}

// 1
// 2
// 3
// 4
// 5
```

## **В каких случаях использовать тот или иной пакет стандартной библиотеки**

В качестве небольшого отступления рассмотрим вопрос о целесообразности использования того или иного метода чтения / записи. Если объем данных небольшой, то разумно использовать функции из пакета io/ioutil - они позволяют нам не заботиться о закрытии файла (кроме функции ReadAll, которая в качестве аргумента получает тип io.Reader), кроме того, все данные считываются / записываются за раз. Стоит дополнить, что многие методы io/ioutil это просто удобные обертки (абстракции) под капотом которых тот же os.OpenFile и тд. Поэтому если хочется более близкий доступ к системе и возможностям используйте os.

Но что если объем данных велик, или не все данные используются единовременно (или готовятся к записи постепенно)? Тогда правильно будет отдать предпочтение пакету bufio, который может считывать данные поэтапно, в т.ч. построчно, записывать данные постепенно.

Если же данные предоставлены нам в специальном формате: csv, json, xml и пр., то правильным будет использовать специальные пакеты Go для работы с такими данными. Стандартная библиотека Go позволяет читать и записывать данные в различных структурированных форматах. Далее мы рассмотрим чтение и запись в формате CSV (данные в столбцах разделены символами "," или ";").

В любом случае многое зависит от конкретных задач и от вашей фантазии. Думайте своей головой ;)

## **encoding/csv**

Пакет encoding/csv предоставляет нам типы csv.Reader и csv.Writer, предназначенные соответственно для чтения и записи файлов в формате csv. По умолчанию разделителем столбцов выступает символ ",". Поскольку работа с этими объектами довольно тривиальна, рассмотрим ее на примерах, не думаю, что могут возникнуть какие-то проблемы с их пониманием:

```go
// Записывать данные, а в дальнейшем читать их мы будем из буфера,
// но его можно заменить любым другим объектом, удовлетворяющим
// интерфейсу io.ReadWriter
buf := bytes.NewBuffer(nil)

w := csv.NewWriter(buf)

for i := 1; i <= 3; i++ {
	// Запись данных может производится поэтапно, например в цикле
	val1 := fmt.Sprintf("row %d col 1", i)
	val2 := fmt.Sprintf("row %d col 2", i)
	val3 := fmt.Sprintf("row %d col 3", i)
	if err := w.Write([]string{val1, val2, val3}); err != nil { // Аргументом Write является срез строк
		// ...
	}
}
w.Flush() // Этот метод приведет к фактической записи данных из буфера csv.Writer в buf

// Либо данные можно записать за один раз
w.WriteAll([][]string{ // Аргументом WriteAll является срез срезов строк
	{"row 4 col 1", "row 4 col 2", "row 4 col 3"},
	{"row 5 col 1", "row 5 col 2", "row 5 col 3"},
})

r := csv.NewReader(buf)

for i := 1; i <= 2; i++ {
	// Читать данные мы тоже можем построчно, получая срез строк за каждую итерацию
	row, err := r.Read()
	if err != nil && err != io.EOF { // Здесь тоже нужно учитывать конец файла
		// ...
	}
	fmt.Println(row)
}

// Либо прочитать данные за один раз
data, err := r.ReadAll()
if err != nil {
	// Когда мы читаем данные до конца файла io.EOF не возвращается, а служит сигналом к завершению чтения
	// ...
}

for _, row := range data {
	fmt.Println(row)
}

// [row 1 col 1 row 1 col 2 row 1 col 3]
// [row 2 col 1 row 2 col 2 row 2 col 3]
// [row 3 col 1 row 3 col 2 row 3 col 3]
// [row 4 col 1 row 4 col 2 row 4 col 3]
// [row 5 col 1 row 5 col 2 row 5 col 3]
```

Соответственно при сравнительно небольшом объеме данных они могут быть прочитаны или записаны за один раз, большой объем данных или их поэтапная обработка могут быть проведены в цикле, условием выхода из цикла может быть получение ошибки io.EOF (для чтения данных).

## **path и path/filepath**

В завершении мы кратко остановимся на двух пакетах, реализующих функционал создания и обработки путей к файлам [path](https://golang.org/pkg/path) и [path/filepath](https://golang.org/pkg/path/filepath/).

Пакет path использует в качестве разделителя символ "/" (слэш), как следствие, он может использоваться только в операционных системах с соответствующим разделителем - [unix системах](https://ru.wikipedia.org/wiki/Unix-%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0) (MaсOS, GNU/Linux и другие). Второй же пакет более универсален и выбирает разделитель в зависимости от операционной системы: для Windows используется обратный слэш - "\".

Оба пакета содержат достаточное количество примеров их работы, мы же остановимся на функции Walk из пакета path/filepath:

```go
func Walk(root string, walkFn WalkFunc) error

// root - директория, с которой начинается обход
// walkFn - функция вида func(path string, info os.FileInfo, err error) error
```

Итак, что же происходит в работе этой функции: Walk рекурсивно обходит все файлы и директории начиная с директории root и для каждого файла (а директория - тоже файл) выполняет функцию walkFn. Давайте рассмотрим работу этой функции на примере:

*Я заранее создал набор директорий и файлов:*

*.*

*├── dir1│   ├── file1│   └── file2├── dir2│   └── file3└── dir3    ├── file4    ├── file5    └── file6*Давайте соберем информацию о всех файлах:

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func walkFunc(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err // Если по какой-то причине мы получили ошибку, проигнорируем эту итерацию
	}

	if info.IsDir() {
		return nil // Проигнорируем директории
	}

	fmt.Printf("Name: %s\tSize: %d byte\tPath: %s\n", info.Name(), info.Size(), path)
	return nil
}

func main() {
	const root = "./test" // Файлы моей программы находятся в другой директории

	if err := filepath.Walk(root, walkFunc); err != nil {
		fmt.Printf("Какая-то ошибка: %v\n", err)
	}

	// Name: file1     Size: 6 byte    Path: test/dir1/file1
	// Name: file2     Size: 6 byte    Path: test/dir1/file2
	// Name: file3     Size: 6 byte    Path: test/dir2/file3
	// Name: file4     Size: 6 byte    Path: test/dir3/file4
	// Name: file5     Size: 6 byte    Path: test/dir3/file5
	// Name: file6     Size: 6 byte    Path: test/dir3/file6
}

```

Размер файлов одинаков, но это не ошибка. Как вы увидели, с помощью этого инструмента мы можем обработать файлы, отвечающие определенным требованиям: с определенным именем, размером, правами на файл и пр.

# **JSON**

## **Общие сведения о формате JSON**

JSON (JavaScript Object Notation) – текстовый формат обмена структурированными данными, основанный на JavaScript. JSON – не единственная доступная нам форма решить данную задачу: аналогичной цели служат XML, YAML и Google’s Protocol Buffers, и каждый имеет свою нишу, однако из-за простоты, удобочитаемости и всеобщей поддержки наиболее широко используется именно JSON.

JSON представляет собой одну из двух структур:

1. набор пар ключ - значение;
2. упорядоченный набор значений.

В качестве значений в JSON могут быть использованы:

1. объект – это неупорядоченное множество пар ключ - значение, заключённое в фигурные скобки «{ }». Ключ описывается строкой, между ним и значением стоит символ «:». Пары ключ - значение отделяются друг от друга запятыми;
2. массив — это упорядоченное множество значений, заключенных в квадратные скобки «[ ]». Значения разделяются запятыми;
3. число (целое или вещественное);
4. литералы true, false (логические) и null;
5. строка.

Рассмотрим пример данных в формате JSON:

```json
{
    "firstName": "Иван",
    "lastName": "Иванов",
    "address": {
        "streetAddress": "Московское ш., 101, кв.101",
        "city": "Ленинград",
        "postalCode": 101101
    },
    "phoneNumbers": [
        "812 123-1234",
        "916 123-4567"
    ]
}
```

Здесь данные представляют из себя набор пар ключ - значение, при этом: firstName и lastName - строки, address - вложенный набор пар ключ - значения, а phoneNumbers - упорядоченный набор значений.

## **Кодирование и декодирование данных**

Marshal и Unmarshal (кодирование и декодирование) данных в формате JSON в стандартной библиотеке Go реализовано в пакете [encoding/json](https://pkg.go.dev/encoding/json?tab=doc).

Наиболее удобным типом для кодирования / декодирования таких данных является структура и срез структур, именно его мы и рассмотрим в рамках этого курса. Но при этом нужно отметить, что в некоторых случаях, когда структура данных нам не известна, мы можем декодировать данные в типы с использованием интерфейсов: interface{}, map[string]interface{}, []interface{}, []map[string]interface{}, однако в дальнейшем такой способ потребует использования рефлексии для анализа таких данных, а это выходит за пределы рассматриваемой темы.

В рассматриваемом пакете мы можем найти 3 функции, позволяющие кодировать / декодировать данные в байтовый срез, чтобы иметь возможность рассматривать конкретные примеры работы, давайте сначала рассмотрим эти функции. Начнем с функции для кодирования данных Marshal:

```go
type myStruct struct {
	Name   string
	Age    int
	Status bool
	Values []int
}

s := myStruct{
	Name:   "John Connor",
	Age:    35,
	Status: true,
	Values: []int{15, 11, 37},
}

// Функция Marshal принимает аргумент типа interface{} (в нашем случае это структура)
// и возвращает байтовый срез с данными, кодированными в формат JSON.
data, err := json.Marshal(s)
if err != nil {
	fmt.Println(err)
	return
}

fmt.Printf("%s", data) // {"Name":"John Connor","Age":35,"Status":true,"Values":[15,11,37]}
```

Как мы видим, данные закодированы и мы даже можем их прочитать. Если же мы хотим получить результат, который лучше подходит именно для чтения человеком (например для использования в качестве конфигурационного файла или для отображения информации на экране компьютера, а не для передачи данных другой программе по сети), мы можем использовать родственную функцию MarshalIndent.

MarshalIndent похож на Marshal, но применяет отступ (indent) для форматирования вывода. Каждый элемент JSON в выходных данных начинается с новой строки, начинающейся с префикса (prefix), за которым следует один или несколько отступов в соответствии с вложенностью:

```go
type myStruct struct {
	Name   string
	Age    int
	Status bool
	Values []int
}

s := myStruct{
	Name:   "John Connor",
	Age:    35,
	Status: true,
	Values: []int{15, 11, 37},
}

data, err := json.MarshalIndent(s, "", "\t")
if err != nil {
	fmt.Println(err)
	return
}

fmt.Printf("%s", data)

//{
//	"Name": "John Connor",
//	"Age": 35,
//	"Status": true,
//	"Values": [
//		15,
//		11,
//		37
//	]
//}
```

Ну и в завершении этого шага рассмотрим последнюю из трех функций Unmarshal, она принимает в качестве аргумента байтовый срез и указатель на объект, в который требуется декодировать данные. Рассмотрим это на уже знакомом примере:

```go
data := []byte(`{"Name":"John Connor","Age":35,"Status":true,"Values":[15,11,37]}`)

type myStruct struct {
	Name   string
	Age    int
	Status bool
	Values []int
}

var s myStruct

if err := json.Unmarshal(data, &s); err != nil {
	fmt.Println(err)
	return
}

fmt.Printf("%v", s) // {John Connor 35 true [15 11 37]}
```

## **Проверка json на правильность**

Мы можем проверить является ли срез байтов форматом json:

```go
type user struct {
	Name     string
	Email    string
	Status   bool
	Language []byte
}

m := user{Name: "John Connor", Email: "test email"}

data, _ := json.Marshal(m)

data = bytes.Trim(data, "{") // испортим json удалив '{'

// функция json.Valid возвращает bool, true - если json правильный
if !json.Valid(data) {
	fmt.Println("invalid json!") // вывод: invalid json!
}

fmt.Printf("%s", data) // вывод: "Name":"John Connor","Email":"test email","Status":false,"Language":null}
```

## **Аннотирование структур**

Давайте рассмотрим вопрос тонкой настройки кодирования / декодирования данных в формате JSON. На предшествующих шагах мы видели, что имена полей объектов JSON выглядят также, как и имена полей структуры, в которую или из которой они кодируются. Но что если мы хотим изменить эти имена? Или кодировать / декодировать только часть полей? Для этого мы можем использовать специальные аннотации - тэги для полей нашей структуры.

Продемонстрировать используемые теги проще всего на примере:

```go
// в общем виде аннотация выглядит так: `json:"используемое_имя,опция,опция"`

type myStruct struct {
	// при кодировании / декодировании будет использовано имя name, а не Name
	Name string `json:"name"`

	// при кодировании / декодировании будет использовано то же имя (Age),
	// но если значение поля равно 0 (пустое значение: false, nil, пустой слайс и пр.),
	// то при кодировании оно будет опущено
	Age int `json:",omitempty"`

	// при кодировании / декодировании поле всегда игнорируется
	Status bool `json:"-"`
}

m := myStruct{Name: "John Connor", Age: 0, Status: true}

data, err := json.Marshal(m)
if err != nil {
	fmt.Println(err)
	return
}

fmt.Printf("%s", data) // {"name":"John Connor"}
```

Как видите, в закодированных в формат JSON данных поле "Name" именуется как "name", а Age и Status отсутствуют, но по разным причинам: Status всегда игнорируется, поскольку установлен тег "-", а Age проигнорирован, т.к. его значение 0 и установлен тег "omitempty". Таким образом, мы можем довольно тонко настроить процесс кодирования / декодирования данных: использовать требуемые нам имена, игнорировать "пустые" (нулевые) значения для экономного использования ресурсов или же просто игнорировать определенные поля структур, которые в работе не будут использоваться.

Завершая рассмотрение этого вопроса нужно отметить следующее: неэкспортируемые поля (имена которых начинаются со строчной буквы) не участвуют в кодировании / декодировании.

## **Типы Encoder и Decoder**

encoding/json позволяет оперировать не только байтовыми срезами, но и работать с уже знакомыми нам типами io.Reader и io.Writer, для этого пакет предоставляет нам типы Encoder и Decoder. Данные типы помимо методов Encode() и Decode() предоставляют нам ряд дополнительных методов, которые могут быть использованы в определенных случаях. Рассмотрим базовые методы, которые применяются наиболее часто:

```go
type testStruct struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

var (
	src = testStruct{Name: "John Connor", Age: 35} // структура с данными
	dst = testStruct{}                             // структура без данных
	buf = new(bytes.Buffer)                        // буфер для чтения и записи
)

enc := json.NewEncoder(buf)
dec := json.NewDecoder(buf)

enc.Encode(src)
dec.Decode(&dst)

fmt.Print(dst) // {John Connor 35}
```

В примере мы сделали следующее: во-первых, создали объекты Encoder и Decoder с помощью функций NewEncoder и NewDecoder соответственно. Каждая из этих функций получила в качестве аргумента буфер, который удовлетворяет одновременно и интерфейсу io.Reader, и интерфейсу io.Writer, соответственно мы смогли сначала записать в него данные, а затем их прочитать, используя методы Encode и Decode соответственно.

В каких ситуациях применять функции Marshal и Unmarshal и методы Encode и Decode соответственно? Все зависит от того, с каким типом данных мы работаем, какой в настоящее время нам более удобен. Обратите внимание, в отличие от данных в формате CSV, с которыми мы работали ранее, данные в формате JSON являются цельным объектом (в т.ч. из-за используемых скобок), поэтому мы не можем кодировать и декодировать их поэтапно.

# **time**

Модуль time стандартной библиотеки предоставляет в наше распоряжение ряд примитивов для работы со временем.

## **type Time**

### **Создание структуры Time**

Первый примитив – структура Time — конкретные дата и время. Создать эту структуру с конкретным значением нам позволяет ряд функций:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// func Now() Time
	// возвращает текущую дату и время
	now := time.Now()

	// func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
	// возвращает дату и время в соответствии с заданными параметрами: годом, месяцем, днем, временем и пр.
	currentTime := time.Date(
		2020,     // год
		time.May, // месяц
		15,       // день
		10,       // часы
		13,       // минуты
		12,       // секунды
		45,       // наносекунды
		time.UTC, // временная зона
	)

	// func Unix(sec int64, nsec int64) Time
	// возвращает дату и время в соответствии с заданными параметрами: секундами и наносекундами, прошедшими с начала эпохи Unix — 01.01.1970 г.
	// https://ru.wikipedia.org/wiki/Unix-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F
	unixTime := time.Unix(
		150000, // секунды
		1,      // наносекунды
	)

	fmt.Println(now.Format("02-01-2006 15:04:05"))         // 15-05-2020 09:58:16
	fmt.Println(currentTime.Format("02-01-2006 15:04:05")) // 15-05-2020 10:13:12
	fmt.Println(unixTime.Format("02-01-2006 15:04:05"))    // 02-01-1970 22:40:00
}

```

Думаю, что у вас резонно должен возникнуть вопрос — что за метод Format был использован при печати значений времени, и почему ему был передан такой странный аргумент? Ничего странного, сейчас мы рассмотрим этот вопрос подробнее.

### **Конвертирование строк в структуру Time**

На практике очень часто возникает задача конвертировать данные о дате и времени из строкового вида, чтобы в дальнейшем получить доступ к методам работы со временем. Однако вариантов строкового представления даты и времени очень много, в некоторых случаях нам интересна только дата, а в некоторых — только время. Как объяснить Go, что к чему в строке? Для этого мы задаем Go шаблон, с которым и сравнивается целевая строка.

Вот основа для шаблона: «Mon Jan 2 15:04:05 MST 2006»: понедельник, 2 января 2006 г. 15:04:05, североамериканское горное стандартное время. В первый раз это может вызвать сложности, но в дальнейшем вы запомните эти базовые дату и время.

За парсинг данных из строковых отвечают 2 функции:

```go
// func Parse(layout, value string) (Time, error)
// парсит дату и время в строковом представлении
firstTime, err := time.Parse("2006/01/02 15-04", "2020/05/15 17-45")
if err != nil {
	panic(err)
}

// LoadLocation находит временную зону в справочнике IANA
// https://www.iana.org/time-zones
loc, err := time.LoadLocation("Asia/Yekaterinburg")
if err != nil {
	panic(err)
}

// func ParseInLocation(layout, value string, loc *Location) (Time, error)
// парсит дату и время в строковом представлении с отдельным указанием временной зоны
secondTime, err := time.ParseInLocation("Jan 2 06 03:04:05pm", "May 15 20 05:45:10pm", loc)
if err != nil {
	panic(err)
}

fmt.Println(firstTime.Format("02-01-2006 15:04:05"))  // 15-05-2020 17:45:00
fmt.Println(secondTime.Format("02-01-2006 15:04:05")) // 15-05-2020 17:45:10
```

Вновь встречаем тот же метод Format, только теперь его аргумент должен быть гораздо более понятен — Format возвращает нам строковое представление времени в соответствии с заданным шаблоном.

### **Методы, возвращающие отдельные элементы структуры**

Таких методов довольно много и в целом они не должны вызвать никаких проблем, для большей части этих методов мы сделаем короткие примеры:

```go
current := time.Date(2020, time.May, 15, 17, 45, 12, 0, time.Local)

// func (t Time) Date() (year int, month Month, day int)
fmt.Println(current.Date()) // 2020 May 15

// func (t Time) Year() int
fmt.Println(current.Year()) // 2020

// func (t Time) Month() Month
fmt.Println(current.Month()) // May

// func (t Time) Day() int
fmt.Println(current.Day()) // 15

// func (t Time) Clock() (hour, min, sec int)
fmt.Println(current.Clock()) // 17 45 12

// func (t Time) Hour() int
fmt.Println(current.Hour()) //17

// func (t Time) Minute() int
fmt.Println(current.Minute()) // 45

// func (t Time) Second() int
fmt.Println(current.Second()) // 12

// func (t Time) Unix() int64
fmt.Println(current.Unix()) // 1589546712

// func (t Time) Weekday() Weekday
fmt.Println(current.Weekday()) // Friday

// func (t Time) YearDay() int
fmt.Println(current.YearDay()) // 136
```

Какие-то дополнительные комментарии к представленным методам не требуются — имена методов и возвращаемые значения говорят сами за себя.

### **Конвертирование структуры Time в строку**

С методом Format мы уже знакомы.

```go
// func (t Time) Format(layout string) string
current := time.Date(2020, time.May, 15, 17, 45, 12, 0, time.Local)
fmt.Println(current.Format("02-01-2006 15:04:05")) // 15-05-2020 17:45:12
```

### **Сравнение структур Time**

```go
firstTime := time.Date(2020, time.May, 15, 17, 45, 12, 0, time.Local)
secondTime := time.Date(2020, time.May, 15, 16, 45, 12, 0, time.Local)

// func (t Time) After(u Time) bool
// true если позже
fmt.Println(firstTime.After(secondTime)) // true

// func (t Time) Before(u Time) bool
// true если раньше
fmt.Println(firstTime.Before(secondTime)) // false

// func (t Time) Equal(u Time) bool
// true если равны
fmt.Println(firstTime.Equal(secondTime)) // false
```

### **Методы, изменяющие структуру Time**

```go
now := time.Date(2020, time.May, 15, 17, 45, 12, 0, time.Local)

// func (t Time) Add(d Duration) Time
// изменяет дату в соответствии с параметром - "продолжительностью"
future := now.Add(time.Hour * 12) // перемещаемся на 12 часов вперед

// func (t Time) AddDate(years int, months int, days int) Time
// изменяет дату в соответствии с параметрами - количеством лет, месяцев и дней
past := now.AddDate(-1, -2, -3) // перемещаемся на 1 год, два месяца и 3 дня назад

// func (t Time) Sub(u Time) Duration
// вычисляет время, прошедшее между двумя датами
fmt.Println(future.Sub(past)) // 10332h0m0s
```

Обратите внимание, что в методах Add и AddDate могут использоваться и отрицательные значения, это позволяет не только «добавлять» время (что видно из названий методов), но и «отнимать» его.

## **type Month**

В предыдущем шаге остался один неразрешенный момент — указания на месяц. Это всего лишь объявленные на уровне модуля time константы, которые выглядят следующим образом:

```go
type Month int

const (
	January Month = 1 + iota
	February
	March
	April
	May
	June
	July
	August
	September
	October
	November
	December
)
```

## **type Duration**

В предыдущем шаге мы увидели такой тип как Duration — продолжительность. Рассмотрим его подробнее. Внутри Duration представляет из себя int64, определяющий количество наносекунд, прошедших между двумя моментами времени.

Создается экземпляр типа Duration одной из следующих функций:

```go
now := time.Now()
past := now.AddDate(0, 0, -1)
future := now.AddDate(0, 0, 1)

// func Since(t Time) Duration
// вычисляет период между текущим моментом и заданным временем в прошлом
fmt.Println(time.Since(past).Round(time.Second)) // 24h0m0s

// func Until(t Time) Duration
// вычисляет период между текущим моментом и заданным временем в будущем
fmt.Println(time.Until(future).Round(time.Second)) // 24h0m0s

// func ParseDuration(s string) (Duration, error)
// преобразует строку в Duration с использованием аннотаций:
// "ns" - наносекунды,
// "us" - микросекунды,
// "ms" - миллисекунды,
// "s" - секунды,
// "m" - минуты,
// "h" - часы.
dur, err := time.ParseDuration("1h12m3s")
if err != nil {
	panic(err)
}
fmt.Println(dur.Round(time.Hour).Hours()) // 1
```

Время — вещь текучая (и в общем, конечно, не вещь вовсе), поэтому не всегда нам удается получить то значение, какое мы ожидаем. Чтобы увидеть конкретный результат, который мы ожидали получить, мы в дополнение к рассматриваемой функции использовали метод Round, округляющий значение до ближайшего целого с заданной точностью.

У типа Duration помимо метода Round, который мы рассмотрели выше, есть ряд других методов, позволяющих вернуть часть значения: часы, минуты, секунды и пр.

```go
func (d Duration) Hours() float64
func (d Duration) Minutes() float64
func (d Duration) Seconds() float64
func (d Duration) Milliseconds() int64
func (d Duration) Microseconds() int64
func (d Duration) Nanoseconds() int64
```

Завершая разговор об этом типе отметим, что модуль time содержит ряд констант типа Duration:

```go
const (
	Nanosecond  Duration = 1
	Microsecond          = 1000 * Nanosecond
	Millisecond          = 1000 * Microsecond
	Second               = 1000 * Millisecond
	Minute               = 60 * Second
	Hour                 = 60 * Minute
)
```

*Для целей решения задач на платформе Stepik необходимо учесть, что ряд методов типа Duration были включены в стандартную библиотеку в версиях 1.9 - 1.13 (Milliseconds, Microseconds, Round), таким образом их использовании в решении приведет к возникновению ошибки (по нашему мнению, таких задач в курсе нет).*

# **Конкурентность (Concurrency) и параллелизм (Parallelism)**

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга. Когда мы начинаем говорить о многопоточной разработке, нужно ввести такие понятия, как **Concurrency** и **Parallelism**. В мире Go есть выражение *«Concurrency is not Parallelism»*. Суть в том, что **Concurrency** — это о дизайне, то есть о том, **как мы проектируем нашу программу.** **Parallelism** — это просто способ выполнения нашего кода.

https://ucarecdn.com/6dd28b1b-bc63-4bbb-973f-845e74cee366/

Конкурентность предполагает работу приложения с двумя и более задачами одновременно, когда происходит создание нескольких процессов, выполняющихся независимо друг от друга.

Приложения могут иметь дело с большим количеством процессов сразу для достижения желаемого поведения. Допустим, есть простенький интернет-магазин. Посмотрим, какие могут быть одновременно выполняемые задачи. Вот их список:

1. Запуск на выполнение баннера с последними предложениями и продуктами cверху страницы.
2. Показ количества пользователей на сайте в данный момент.
3. Обновление содержимого корзины при выборе продуктов.
4. Ведение счётчика времени до следующей распродажи и так далее.

Для интернет-магазина важно, чтобы все эти задачи выполнялись одновременно, ведь нужно удержать пользователей на сайте или в приложении, сделав его максимально привлекательным для них, чтобы они оставили здесь свои деньги. Поэтому можно сделать так, чтобы на простом сайте в фоновом режиме выполнялось множество задач.

На картинке выше у нас несколько задач, выполняемых одновременно, но есть разница в том, как они выполняются. Рассмотрим теперь подробнее.

# **Конкурентное и параллельное выполнение**

https://ucarecdn.com/81faff0e-13f8-4f2f-95e3-0d03a60fddaf/

## **Работа с конкурентными приложениями**

Допустим, у нас одноядерная система и надо выполнить несколько задач, но есть ограничение: одномоментно может быть выполнена лишь одна задача.

В модели конкурентного выполнения имеет место переключение контекста между задачами: приложение работает с несколькими задачами, но не может выполнять их все вместе, ведь ядро всего одно. Переключение контекста происходит настолько быстро, что создаётся ощущение, что задачи выполняются одновременно.

Фактор параллельного выполнения здесь отсутствует: параллельные процессы не могут выполняться вместе просто потому, что наша система одноядерная.

На второй картинке в нижней части проиллюстрирована *конкурентность без параллелизма. З*десь показано конкурентное выполнение двух задач с переключением контекста: одномоментно может быть выполнена лишь одна задача.

## **Добавим приложению параллелизма**

В случае с одноядерной системой у нас были ограничения по ресурсам. Если мы добавим несколько ядер, ресурсов станет больше и приложение сможет одновременно выполнять на разных ядрах множество задач. В верхней части той же картинки показано, как на разных ядрах одновременно и параллельно выполняются две задачи.

Конкурентность и параллелизм — очень похожие понятия, но мне кажется, что разницу вы уже уловили.

Таким образом, увеличивая сложность системы, можно увеличить и сложность решаемых с её помощью задач: работая с Golang, мы можем масштабировать приложение, с лёгкостью переходя от конкурентного исполнения к параллельному. Масштабируемость в Golang — это легко!

!https://habrastorage.org/webt/uk/tr/es/uktresizsgqpphu4mkmjlep00fe.png

# **Горутины**

Горутины реализуют в Golang обёрточный функционал потоков, а управляются они скорее из среды выполнения Go, нежели из операционной системы.

Среда выполнения Go распределяет или забирает ресурсы памяти у горутин. Горутина во многом похожа на поток тем, что касается выполнения множества задач, но потребляет меньше ресурсов, чем потоки операционной системы. Горутина не имеет полного соответствия с потоками.

https://ucarecdn.com/60319e3d-e13f-4f1d-907e-76b7ed8cbf90/

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены. Главная особенность горутин состоит в том, что они могут выполняться параллельно. То есть на многоядерных архитектурах есть возможность выполнять отдельные горутины на отдельных ядрах процессора, тем самым горутины будут выполняться паралелльно, и программа завершится быстрее.

В Go независимо запущенная задача называется **горутиной**. Горутины похожи на *корутины (из котлина)*, *процессы* или *потоки* в других языках, хотя у них есть много своих особенностей. Их создание рационально, оно значительно упрощает процесс управления многими конкурентными операциями.

Преимущества горутин:

1. Они легковесны.
2. Легко и без проблем масштабируют.
3. Они — практически потоки.
4. Требуют меньше памяти (2KB).
5. Предоставляют дополнительную память горутинам во время выполнения.

## **Запуск горутины в Golang**

Запуск горутины очень прост, достаточно прописать перед функцией ключевое слово "go", например:

```go
package main

import "fmt"

func main() {
	go myFunc()
}

func myFunc() {
	fmt.Println("hello")
}
```

Все действительно так просто. Вот только если выполнить эту программу, то мы ничего не увидим. Это связано с тем, что после запуска myFunc в отдельной горутине (на это указывает ключевое слово go), функция main продолжает выполняться и завершается, не дожидавшись завершения выполнения всех прочих горутин, соответственно myFunc просто не успевает завершить выполнение. Go предусматривает несколько способов синхронизации выполнения горутин и мы рассмотри их в этом уроке.

Небольшое отступление. Go очень быстр, а нам требуется увидеть результат выполнения работы, а значит - замедлить нашу программу. Для этого мы будем использовать пакет [time](https://pkg.go.dev/time?tab=doc) из стандартной библиотеки который был рассмотрен на прошлом уроке. Внесем небольшие изменения в наш пример:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go myFunc()
	time.Sleep(1 * time.Second) // Пауза в 1 секунду
}

func myFunc() {
	fmt.Println("hello")
}

// Вывод: hello
```

Теперь все работает. Количество горутин, которые мы можем запустить, не ограничено.

**Анонимные горутины**

```go
//Самовызывающаяся анонимная горутина
go func() {
 fmt.Println("Привет, я анонимная горутина")
}()
```

Это позволяет писать код, который используется в одном месте и сразу вызвать, не заботясь об объявлении функции

### **Функция main()**

Удивительно, но функция main() вызывает свою собственную горутину.

**Замечание**

> По умолчанию используется кол-во ядер вашего процессора. Но мы можем изменить количество используемых ядер простой строчкой кода. Приложению будет дана команда перейти на 4 ядра:runtime.GOMAXPROCS(4)
> 

# **Каналы**

Основное преимущество Go заключается в том, что он не просто позволяет выполнять несколько задач параллельно и конкурентно, но позволяет организовать удобную связь между горутинами при выполнении этих задач. Для этой цели используются каналы, по которым как по системе пневматической почты в старых офисах мы можем передавать данные.

Канал представляет собой механизм связи, который позволяет одной горутине отправлять некоторые значения другой горутине. Каждый канал является средством передачи значений определённого типа, который называется типом элементов канала.

Чтобы создать канал используется встроенная функция **make**:

```go
channel := make(chan int)    // channel имеет тип 'chan int'
```

Как и отображение, канал является ссылкой на структуру данных. Копируя или передавая канал в функцию в качестве аргумента, мы копируем ссылку на одну и ту же структуру данных. Нулевым значением канала является nil.

Канал имеет две основные операции:

- **Отправление (запись)** - передаёт через канал значение из одной горутины в другую.
- **Получение (чтение)** - получение через канал значения из другой горутины.

Обе операции записываются с использованием оператора **<-**, например:

```
channel <- num    // отправляет в канал channel значение num
num = <- channel  // получение из канала channel в переменную num
```

Чтение из канала может производится в цикле:

```go
for v := range channel {
    ...
}
```

В приведенном примере чтение из канала будет осуществляться пока канал channel открыт.

Каналы поддерживают операцию закрытия встроенной функцией close:

```
close(channel)
```

Эта функция устанавливает, что данные с помощью этого канала больше не будут передаваться.

Попытка передать данные в закрытый канал приведет к возникновению аварийной ситуации, однако операция получения будет работать и с закрытым каналом - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Тип канала - не единственная его характеристика. Каждый канал имеет длину и емкость (их можно получить с помощью знакомых нам функций len() и cap()): длина - количество значений в канале в текущий момент, емкость - размер буфера. Наличие буфера позволяет записать в канал определенное количество значений, не вычитывая их при этом.

При отправлении значения в небуферизованный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.

Для того, чтобы разобраться в этом вопросе, рассмотрим следующий пример:

```go
c := make(chan int, 1) // здесь 1 - размер буфера
fmt.Println(len(c), cap(c)) // 0 1
c <- 1
fmt.Println(len(c), cap(c)) // 1 1
<-c
```

Если же размер буфера будет 0, то выполнение программы приведет к панике, так как записанное значение одновременно с записью в канал не вычитывается. Но об этом мы расскажем подробнее чуть позже, в настоящее время достаточно знать, что такое буферезированные каналы:

```go
pipe := make(chan int)     // небуферизованный канал
pipe := make(chan int, 0)  // небуферизованный канал
pipe := make(chan int, 5)  // буферизованный канал с ёмкостью 5
```

Буферизованные каналы имеют очередь элементов. Размер очереди задается при создании канала:

```go
channel := make(chan string, 3) // буферизованный канал, который может хранить три строковых значения
```

Операция отправления в буферизованный канал добавляет элемент в конец очереди:

```
channel <- "A"
```

Операция получения извлекает первый элемент из очереди:

```
fmt.Println(<-channel) // "A"
```

Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.

Выбор между буферизованным и небуферизованным каналом, как и выбор емкости каналов, может влиять на корректность работы программы в целом. Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана ****с операцией получения. В случае буферизованных каналов, эти операции разделены.

### **Блокирование выполнения горутины**

В некоторых случаях горутины могут быть заблокированы:

- блокирование при записи: горутина, посылающая данные в канал, блокируется, пока другая горутина не прочитает данные из этого канала;
- блокирование при чтении: горутина, получающая данные из канала, может быть заблокирована до момента получения данных из канала.

Подробнее про блокировки мы расскажем в следующем уроке.

# **Блокировки**

В некоторых случаях горутины могут быть заблокированы. Это нужно для того, чтобы горутины могли синхронизироваться между собой.

## **Блокировка при записи**

Горутина, посылающая данные в канал, блокируется, покуда другая горутина не прочитает данные из него. Всё просто.

## **Блокировка при чтении**

Горутина, получающая данные из канала,  может быть заблокирована до момента получения данных в канал. Аналогично блокировке при записи.

Программе нет смысла использовать системные ресуры в простое - это затратно по памяти. Для полного понимания, блокировки горутин можно представить как сделку между двумя людьми: пока покупатель не заплатит - продавец не предоставит товар.

## **Select-case**

Используя конструкцию ***select-case*** можно избежать блокирующего поведения.

```go
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}

```

При запуске кода выше, в терминале можно будет увидеть такой вывод, это происходит потому горутина прочитает из канала данные, если только они там есть, в противном случае выполняется блок ***quit***:

```go
0
1
1
2
3
5
8
13
21
34
quit
```

# **Синхронизация горутин с помощью каналов**

Каналы предназначены для передачи данных, но могут быть использованы не только для этой цели. В частности каналы используются для синхронизации выполнения горутин. Вернемся к примеру из [этого шага](https://stepik.org/lesson/360357/step/3?unit=344766) и изменим его таким образом, чтобы не использовать пакет time:

```go
package main

import (
	"fmt"
)

func main() {
	done := make(chan struct{})
	go myFunc(done)
	<-done
}

func myFunc(done chan struct{}) {
	fmt.Println("hello")
	close(done)
}

```

Разберем приведенный пример. Мы создаем канал done, который будет использован для синхронизации (тип канала не важен, но пустая структура не занимает памяти, поэтому использование такого типа крайне выгодно). myFunc закрывает этот канал после завершения работы. После запуска myFunc мы ждем, что канал done вернет нам какое-то значение. В это время myFunc выполняет свою работу и закрывает канал. Т.к. канал закрыт, а значений в канале нет, то Go делает вывод, что done уже ничего не вернет и ожидать значения из него не нужно - функция main продолжает выполнение.

Любой язык программирования рождает определенные шаблоны разработки, и Go не является исключением, на Go такая программа должна выглядеть так:

```go
package main

import (
	"fmt"
)

func main() {
	<-myFunc()
}

func myFunc() <-chan struct{} {
	done := make(chan struct{})
	go func() {
		fmt.Println("hello")
		close(done)
	}()
	return done
}

```

Теперь канал для синхронизации создается самой функцией myFunc(), полезная работа выполняется в отдельной горутине. А еще вы могли обратить внимание, что myFunc возвращает <-chan struct{}. Стрелка слева от ключевого слова chan означает, что возвращаемый канал предназначен только для чтения из него. Аналогичным образом мы можем вернуть из функции или передать в нее в качестве аргумента канал, предназначенный только для записи - chan<- struct{}.

# **Синхронизация горутин с помощью sync.WaitGroup**

Еще одну возможность по синхронизации горутин представляет использование типа sync.WaitGroup. Этот тип позволяет определить группу горутин, которые должны выполняться вместе как одна группа. И можно установить блокировку, которая приостановит выполнение функции, пока не завершит выполнение вся группа горутин. Например:

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	wg := new(sync.WaitGroup)

	for i := 0; i < 5; i++ {
		wg.Add(1) // Увеличиваем счетчик горутин в группе
		go work(i, wg) // Вызываем функцию work в отдельной горутине
	}

	wg.Wait() // ожидаем завершения всех горутин в группе
	fmt.Println("Горутины завершили выполнение")
}

func work(id int, wg *sync.WaitGroup)  {
	defer wg.Done()
	fmt.Printf("Горутина %d начала выполнение \n", id)
	time.Sleep(2 * time.Second)
	fmt.Printf("Горутина %d завершила выполнение \n", id)
}
```

Вначале определяем группу в виде переменной `wg sync.WaitGroup`.

В цикле запускаем функцию work 5 раз в отдельных горутинах, при этом увеличиваем счетчик горутин в группе с помощью метода Add. Число, которое передается в метод Add определяет значение внутреннего счетчика активных элементов.

Чтобы сигнализировать, что элемент группы завершил свое выполнение, в горутине необходимо вызвать метод Done().

Метод Wait блокирует выполнение функции main до завершения выполнения всех горутин, входящих в группу - его мы вызываем после запуска горутин, чтобы дождаться результата их выполнения. Когда внутренний счетчик активных элементов в группе wg станет равен 0, функция main будет разблокирована и продолжит свое выполнение.

```
Горутина 4 начала выполнение
Горутина 0 начала выполнение
Горутина 1 начала выполнение
Горутина 3 начала выполнение
Горутина 2 начала выполнение
Горутина 2 завершила выполнение
Горутина 0 завершила выполнение
Горутина 4 завершила выполнение
Горутина 1 завершила выполнение
Горутина 3 завершила выполнение
Горутины завершили выполнение
```

# **Мьютексы**

Рассмотрим такой пример:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var x int
	wg := new(sync.WaitGroup)

	for i := 0; i < 1000; i++ {
		// Запускаем 1000 экземпляров горутины, увеличивающей счетчик на 1
		wg.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			x++
		}(wg)
	}

	wg.Wait()

	// По идее значение счетчика должно быть 1000, но крайне вероятно, что этого не произойдет
	fmt.Println(x)
}

```

Кажется, что результат выполнения работы этой программы будет 1000, но так почти никогда не будет - попробуйте сами. Почему так? Представим себе что первая горутина получает значение переменной x, а вторая горутина одновременно с этим выполняют такую же операцию. Тогда обе горутины считают, что x = 0, затем производятся расчеты и обе горутины присваивают x значение 1 (0 + 1), в результате работа одной из горутин напрасна.

Чтобы не потерять результаты вычислений мы можем использовать тип sync.Mutex:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var x int
	wg := new(sync.WaitGroup)
	mu := new(sync.Mutex)

	for i := 0; i < 1000; i++ {
		// Запускаем 1000 экземпляров горутины, увеличивающей счетчик на 1
		wg.Add(1)
		go func(wg *sync.WaitGroup, mu *sync.Mutex) {
			defer wg.Done()
			mu.Lock()
			x++
			mu.Unlock()
		}(wg, mu)
	}

	wg.Wait()
	fmt.Println(x)
}

```

Мютекс имеет методы Lock и Unlock - причем Lock невозможно выполнить подряд дважды, если между этими вызовами не выполнить Unlock. Соответственно если одна горутина взяла Lock, то другие горутины этой операции выполнить уже не могут и вынуждены ожидать, пока взявшая Lock горутина не выполнит Unlock.

# **Пакет time и параллелизм**

### **Мы уже прошли пакет time, но есть функции которые связаны с параллелизмом.**

Перед тем как перейти к рассмотрению типов Timer и Ticker рассмотрим упрощенные их аналоги:

```
// func Sleep(d Duration)
// программа засыпает на заданное время
time.Sleep(time.Second * 2) // спим ровно 2 секунды

// func After(d Duration) <-chan Time
// создает канал, который через заданное время вернет значение
timer := time.After(time.Second)
<-timer // значение будет получено из канала ровно через 1 секунду

// func Tick(d Duration) <-chan Time
// создает канал, который будет посылать сигналы постоянно через заданный промежуток времени
ticker := time.Tick(time.Second)
count := 0

for {
	<-ticker
	fmt.Println("очередной тик")
	count++
	if count == 3 {
		break
	}
}

// очередной тик
// очередной тик
// очередной тик
```

Далее мы разберем более сложные типы Timer и Ticker и приведем примеры их работы, назначение функций After и Tick аналогично.

# **Таймеры и тикеры**

### **type Timer**

Timer по своей сути очень похож на результат работы After, но позволяет остановить таймер или изменить время его выполнения:

```go
t := time.NewTimer(time.Second) // создаем новый таймер, который сработает через 1 секунду
go func() {
	<-t.C // C - канал, который должен вернуть значение через заданное время
}()
t.Stop() // но мы можем остановить таймер и раньше установленного времени

t.Reset(time.Second * 2) // пока таймер не сработал, мы можем сбросить его, установив новый срок выполнения
<-t.C
```

### **type Ticker**

Ticker же работает как функция Tick, но может быть остановлен:

```go
func NewTicker(d Duration) *Ticker // создаем новый Ticker
func (t *Ticker) Stop() // останавливаем Ticker
```

### **Пример работы**

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	<-work()
	/*
	 * тик-так
	 * тик-так
	 * тик-так
	 * тик-так
	 */
}

func work() <-chan struct{} {
	done := make(chan struct{}) // канал для синхронизации горутин

	go func() {
		defer close(done) // синхронизирующий канал будет закрыт, когда функция завершит свою работу

		stop := time.NewTimer(time.Second)

		tick := time.NewTicker(time.Millisecond * 200)
		defer tick.Stop() // освободим ресурсы, при завершении работы функции

		for {
			select {
			case <-stop.C:
				// stop - Timer, который через 1 секунду даст сигнал завершить работу
				return
			case <-tick.C:
				// tick - Ticker, посылающий сигнал выполнить работу каждый 200 миллисекунд
				fmt.Println("тик-так")
			}
		}
	}()

	return done
}
```

В примере таймер использован для передачи сигнала о необходимости завершить работу, а тикер выдавал «билет» на выполнение работы. Такой подход обычно используется для балансировки нагрузки.

Допустим, нам необходимо запросить у Вконтакте данные о 100 аккаунтах, если мы попытаемся просто в цикле запросить все эти данные, то в первую же секунду получим бан, потому что API Вконтакте допускает совершать не более 3 запросов в секунду. Используя тикер мы можем отправлять запрос каждые 350 миллисекунд. Похожего эффекта можно достичь с помощью функции Sleep, но предоставляя каналы таймеры и тикеры могут работать в многопоточных приложениях:

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	tick := time.NewTicker(time.Second)
	defer tick.Stop()

	wg := new(sync.WaitGroup)

	for i := 1; i <= 5; i++ {
		wg.Add(1)
		go worker(i, tick.C, wg)
	}

	wg.Wait()

	/*
	 * worker 1 выполнил работу
	 * worker 5 выполнил работу
	 * worker 3 выполнил работу
	 * worker 4 выполнил работу
	 * worker 2 выполнил работу
	 */
}

func worker(id int, limit <-chan time.Time, wg *sync.WaitGroup) {
	defer wg.Done()
	<-limit
	fmt.Printf("worker %d выполнил работу\n", id)
}
```

# **Использование select в канале горутин**

До этого мы использовали один канал для ожидания ответа от нескольких горутин. Он хорошо работает, когда все горутины возвращают один и тот же тип значения, но так происходит не всегда. Часто нам нужно подождать два или более значения разных типов.

Одним из примеров этого является случай ожидания некоторых значений по каналу, но ждать слишком долго нельзя. Возможно, мы немного нетерпеливы по отношению к сонным гоферам, и терпение это не вечно. Или нам еще может потребоваться установить тайм-аут сетевого запроса после несколько секунд, а не несколько минут.

К счастью стандартная библиотека Go предоставляет полезную функцию `time.After`, которая может нам значительно помочь. Она возвращает канал, который получает значение по прошествии некоторого времени (горутина, что отправляет значение, является частью среды выполнения Go).

Нам нужно продолжать получать значения от сонных гоферов, пока они не закончат спать, или у нас не кончится терпение. Это означает, что нам нужно одновременно ждать таймера одного и другого канала. Оператор `select` позволяет нам это сделать.

Оператор `select` выглядит как оператор [switch](https://golangs.org/go-for-if-else-switch#switch). Каждый `case` внутри `select` содержит канал получения или отправки. `select` ждет завершения одного `case`, а затем запускает его и связанный с ним оператор `case`. Как будто `select` смотрит на оба канала сразу и действует, когда видит, что что-то случается с любым из них.

В следующем листинге используется `time.After` для создания канала тайм-аута, а затем используется `select` для ожидания каналом сонных гоферов и тайм-аута канала.

```go
timeout := time.After(2 * time.Second)

for i := 0; i < 5; i++ {

    select { // Оператор select

    case gopherID := <-c: // Ждет, когда проснется гофер

        fmt.Println("gopher ", gopherID, " has finished sleeping")

    case <-timeout: // Ждет окончания времени

        fmt.Println("my patience ran out")

        return // Сдается и возвращается

    }

}
```

**На заметку:** Когда в операторе `select` нет ни одного случая `case`, он будет ждать вечно. Это может оказаться полезным для остановки возвращения функции `main`, когда вы начинаете горутины, что должны перестать выполняться на неопределенное время.

Не очень интересно, когда все гоферы спят в точности по три секунды, потому что терпение всегда заканчивается до момента их пробуждения. Гоферы в следующем листинге спят случайное количество времени. При запуске вы увидите, что некоторые гоферы просыпаются вовремя, а некоторые нет.

```go
func sleepyGopher(id int, c chan int) {
    time.Sleep(time.Duration(rand.Intn(4000)) * time.Millisecond)
    c <- id
}
```

Данный паттерн полезен, когда вам нужно ограничить время на выполнения определенной операции. Поместив действие внутрь горутины и отправив его каналу, когда тот завершен, можно добиться фиксированного времени практически для всего в Go.

Хотя мы перестали ждать горутин, если мы не вернулись из функции `main`, они все еще будут существовать, занимая память. Если возможно, лучше завершить их работу.

## **Select - switch для каналов**

Как мы уже говорили выше - оператор `select` выглядит как оператор switch. Если же ни один из каналов значений не возвращает, выполняется блок default:

```go
tick1 := time.After(time.Second)
tick2 := time.After(time.Second * 2)
select {
case <-tick1:
	fmt.Println("Получено значение из первого канала")
case <-tick2:
	fmt.Println("Получено значение из второго канала")
// Блок default выполнится раньше блока case - 1 секунда слишком много для Go
default:
	fmt.Println("Действие по умолчанию")
}

// Действие по умолчанию
```

В приведенном примере будет выполнен блок default, если же этот блок убрать - будет выполнен блок, получающий значение из канала tick1.

# **Дополнительные материалы для дальнейшего изучения параллелизма в Go**

### **Сложно охватить все темы связанные с многопоточностью, поэтому предлагаем вам материалы для дальнейшего изучения:**

- **[Как не ошибиться с конкурентностью в Go](https://habr.com/ru/company/avito/blog/466495/)**
- **[Разбираемся с новым sync.Map в Go 1.9](https://habr.com/ru/post/338718/)**
- **[Конкурентность в Go на примере создания игры для изучения Марса](https://golangs.org/life-mars)**
- **[Как работает планировщик Go](https://habr.com/ru/post/489862/)**
- **[GO Scheduler: теперь не кооперативный?](https://habr.com/ru/post/502506/)**
- **[Танцы с мьютексами в Go](https://habr.com/ru/post/271789/)**

# **Полезные материалы**

Мы рассмотрели далеко не все возможности Go, так что оставляем здесь материалы по Go для дальнейшего изучения, а так же инструменты для разных целей. Этот шаг будет дополняться, так же пишите свои ресурсы в комментарии.

### **В качестве продолжения обучения**

- **[Алгоритмы и структуры данных](https://stepik.org/course/1547) - задания можно выполнять на Golang**

### **Другое**

- **Самый полный и актуальный учебник это официальная [документация](https://golang.org/pkg/)**
- **[Уроки для изучения Golang - golangs.org](https://golangs.org/)**
- **[A curated list of awesome Go frameworks, libraries and software](https://awesome-go.com/)**
- **[4gophers: Статьи разных уровней про Go](https://4gophers.ru/)**
- **[Программирование на Go by digitalocean](https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go-ru)**
- **[Бенчмарки в Go](https://habr.com/en/post/268585/)**
- **[Go vs Python](https://habr.com/en/post/488644/)**
- **Book [The Go Programming Language](https://www.gopl.io/)**
- **[Golang: основы для начинающих](https://tproger.ru/translations/golang-basics/)**
- **[Список книг по Go](https://tproger.ru/books/go-books/)**
- **[Go на reddit](https://www.reddit.com/r/golang/)**
- **[Полезные короткие статьи](https://www.devdungeon.com/content/go)**
- **[Является ли Go языком ООП?](https://habr.com/en/post/225907/)**
- **[50 оттенков Go: ловушки, подводные камни и распространённые ошибки новичков](https://habr.com/ru/company/mailru/blog/314804/#22)**
- **[golang-developer-roadmap](https://github.com/Alikhll/golang-developer-roadmap)**
- **[Подводные камни Go (english)](https://go-traps.appspot.com/)**
- **[Большой список видеокурсов по Go](https://coursehunters.net/backend/google-go)**
- **[Go на Хабре](https://habr.com/ru/search/?target_type=posts&q=[golang]&order_by=date)**
- **[С чего начать новичку в Go](https://habr.com/ru/post/269355/)**
- **[reference manual for the Go programming language](https://golang.org/ref/spec)**
- **[Welcome to a tour of Go](https://tour.golang.org/list)**
- **[Go с нуля (перевод книги)](https://rtfm.co.ua/books-translations/go-s-nulya/)**
- **[Go в примерах](https://gobyexample.ru/)**
- **[Golang Web Scraping](https://github.com/lorien/awesome-web-scraping/blob/master/golang.md)**
- **[Разбираемся в Go: пакеты bytes и strings](https://habr.com/en/post/307554/)**
- **[Введение в систему модулей Go](https://habr.com/ru/post/421411/)**
- **[Зачем в Go амперсанд и звёздочка (& и *)?](https://habr.com/ru/post/339192/)**
- **[Ошибки это значения](https://4gophers.ru/articles/oshibki-eto-znacheniya/)**
- **[Как писать Go-пакеты](https://habr.com/ru/company/ruvds/blog/464289/)**
- **[Полное руководство по массивам и срезам в Golang](https://habr.com/ru/company/otus/blog/465613/)**
- **[Учебные курсы по Go (English)](https://www.tutorialspoint.com/go/index.htm)**
- **[Работа с ошибками в Go 1.13](https://habr.com/ru/company/mailru/blog/473658/)**

### **Многопоточность**

- **[Как не ошибиться с конкурентностью в Go](https://habr.com/ru/company/avito/blog/466495/)**
- **[Разбираемся с новым sync.Map в Go 1.9](https://habr.com/ru/post/338718/)**
- **[Конкурентность в Go на примере создания игры для изучения Марса](https://golangs.org/life-mars)**
- **[Как работает планировщик Go](https://habr.com/ru/post/489862/)**
- **[Танцы с мьютексами в Go](https://habr.com/ru/post/271789/)**

### **Благодарности данным ресурсам**

- **[golangs.org](https://golangs.org/)**
- **[golang-book.ru](http://golang-book.ru/)**
- **[metanit.com](https://metanit.com/)**